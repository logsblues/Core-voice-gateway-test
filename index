/**
 * ============================================================
 * VOICE GATEWAY v7.0.0 â€” ENTERPRISE EDITION (Blue Core Ready)
 * ============================================================
 *
 * Complete OOP architecture based on v6.2.0 with NEW v7 features:
 * - v6.2.0 Full codebase (22 classes, resilience, observability)
 * - v7.0.0 NEW: Dynamic Tools from DB (bc_agent_tools)
 * - v7.0.0 NEW: ElevenLabs TTS support (stability, similarity_boost, style, speed)
 * - v7.0.0 NEW: Playbooks injection (bc_agent_playbooks)
 * - v7.0.0 NEW: Tool call logging (persisted to bc_call_prep_sessions.tool_calls_log)
 * - v7.0.0 NEW: Configurable STT (stt_provider, stt_language from bc_agents)
 * - v7.0.0 NEW: Configurable AI model (ai_model from bc_agents)
 * - v7.0.0 NEW: Dynamic temperature / max_tokens (from bc_agents)
 *
 * ARCHITECTURE: 10 clearly separated sections with full OOP encapsulation.
 *
 * CLASSES (27 â€” 22 original + 5 new):
 *   Utilities:    Logger, Validator, Parser
 *   Resilience:   RetryManager, CircuitBreaker, RateLimiter
 *   State:        SessionManager
 *   External:     SupabaseClient, CRMToolsClient, WebhookClient,
 *                 ElevenLabsTTSClient (NEW v7)
 *   Business:     LanguageDetector, VoicemailDetector, AutoHangupManager,
 *                 SpamFilter, ToolDeduplicator, PromptBuilder, VoiceMapper,
 *                 BusinessNameDetector, ResponseLockManager,
 *                 DynamicToolLoader (NEW v7), PlaybookLoader (NEW v7),
 *                 ToolCallLogger (NEW v7)
 *   Execution:    ToolExecutor
 *   Handlers:     OpenAIHandler, TwilioHandler
 *   Observability: MetricsCollector, HealthCheck
 *
 * KEY FEATURES (v6.2.0 inherited):
 * - Multi-tenant architecture (zero hardcoded company logic)
 * - Circuit breakers & exponential backoff for all external services
 * - Automatic language detection with dynamic switching
 * - Rate limiting per tenant and per IP
 * - Spam filtering and voicemail/IVR detection
 * - Prewarm sessions with forceNewSession/skipPrewarm override
 * - Dynamic instructions: full (replace) or addon (merge) modes
 * - Base64 instruction decoding (dynB64, fmB64) from TwiML URL
 * - Auto-hangup after goodbye pattern (5s timeout)
 * - Tool deduplication with argument analysis
 * - Response locking to prevent concurrent OpenAI responses
 * - Business name detection (prevents greeting with company names)
 * - Structured JSON logging with contextual information
 * - Health checks with service status + metrics endpoint
 * - Graceful shutdown (SIGTERM/SIGINT) with forced exit on fatal errors
 * - Transcript sync to Supabase
 * - Webhook support for post-call events
 * - Blue Core (bc_agents, bc_companies, bc_call_prep_sessions) support
 * - Full exports for testing
 *
 * NEW FEATURES (v7.0.0):
 * - Dynamic tool loading from bc_agent_tools with 5min cache
 * - ElevenLabs TTS with full voice_settings support
 * - Playbook injection from bc_agent_playbooks (opening_script, qualifying_questions, objection_handlers)
 * - Tool call logging persisted to bc_call_prep_sessions.tool_calls_log
 * - Configurable STT provider/language/model from bc_agents
 * - Configurable AI model from bc_agents (ai_model field)
 * - Dynamic temperature/max_tokens from bc_agents
 * - Cache invalidation endpoint (POST /cache/invalidate)
 *
 * BLUE CORE TEST DATA:
 *   Company: bc000000-0000-0000-0000-000000000001 (Blue Core, sandbox)
 *   Agent:   bc000000-0000-0000-0000-000000000002 (Nanyeli, es, openai voice)
 *
 * @version 7.0.0
 * @license MIT
 */

import WebSocket, { WebSocketServer } from "ws";
import http from "http";

// ============================================================
// SECTION 1: CONFIGURATION & CONSTANTS
// ============================================================

const VERSION = "7.0.0";
const PORT = process.env.PORT || 10000;

// Environment variables (required)
const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_SERVICE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;
const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
const VOICE_GATEWAY_TOKEN = process.env.VOICE_GATEWAY_TOKEN;

// Environment variables (optional)
const OPENAI_REALTIME_MODEL = process.env.OPENAI_REALTIME_MODEL || "gpt-4o-realtime-preview-2024-12-17";
const ELEVENLABS_API_KEY = process.env.ELEVENLABS_API_KEY || "";  // NEW v7
const ENABLE_WEBHOOKS = process.env.ENABLE_WEBHOOKS !== "false";
const ENABLE_METRICS = process.env.ENABLE_METRICS !== "false";

// External service URLs
const CRM_TOOLS_URL = SUPABASE_URL + "/functions/v1/render-crm-tools";
const UPSERT_CALL_RECORD_URL = SUPABASE_URL + "/functions/v1/upsert-call-record";
const SYNC_TRANSCRIPT_URL = SUPABASE_URL + "/functions/v1/sync-transcript";

// Timing constants
const PREWARM_SESSION_TTL_MS = 90000;
const PREWARM_CLEANUP_INTERVAL_MS = 15000;
const SESSION_UPDATE_TIMEOUT_MS = 3000;
const AUTO_HANGUP_TIMEOUT_MS = 5000;
const RINGBACK_INTERVAL_MS = 100;
const TOOL_EXECUTION_TIMEOUT_MS = 30000;
const WEBHOOK_TIMEOUT_MS = 10000;

// Retry constants
const MAX_RETRIES = 3;
const BASE_RETRY_DELAY_MS = 100;
const MAX_RETRY_DELAY_MS = 5000;

// Circuit breaker constants
const CIRCUIT_BREAKER_FAILURE_THRESHOLD = 5;
const CIRCUIT_BREAKER_RESET_TIMEOUT_MS = 60000;

// Rate limiting constants
const RATE_LIMIT_CALLS_PER_TENANT_CONCURRENT = 50;
const RATE_LIMIT_CALLS_PER_TENANT_HOUR = 1000;
const RATE_LIMIT_REQUESTS_PER_IP_MINUTE = 60;

// Cache constants (NEW v7)
const TOOL_CACHE_TTL_MS = 5 * 60 * 1000;    // 5 minutes
const PLAYBOOK_CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes

// Default values
const DEFAULT_TIMEZONE = "America/New_York";
const DEFAULT_LANGUAGE = "es";
const DEFAULT_VOICE = "alloy";

// Session pools
const sessions = new Map();
const prewarmSessions = new Map();
const agentConfigCache = new Map();
const tenantCallCounts = new Map();
const ipRequestCounts = new Map();

// Ringback silence frame (8kHz ulaw, ~100ms)
const RINGBACK_SILENCE_FRAME = Buffer.alloc(800).toString("base64");

// Valid OpenAI voices
const VALID_OPENAI_VOICES = [
  "alloy", "ash", "ballad", "coral", "echo",
  "sage", "shimmer", "verse", "marin", "cedar"
];

// Supported languages (with detection patterns)
const SUPPORTED_LANGUAGES = {
  es: {
    name: "Spanish",
    patterns: [
      /\b(hola|buenos dÃ­as|gracias|por favor|cÃ³mo estÃ¡s|sÃ­|no)\b/i,
      /[Ã±Ã¡Ã©Ã­Ã³Ãº]/
    ]
  },
  en: {
    name: "English",
    patterns: [
      /\b(hello|hi|thank you|please|how are you|yes|no)\b/i
    ]
  }
};

// Voicemail/IVR detection patterns
const VOICEMAIL_PATTERNS = [
  /leave\s+(a\s+)?message/i, /deja\s+(tu\s+)?mensaje/i,
  /grabe\s+su\s+mensaje/i, /after\s+the\s+(beep|tone)/i,
  /at\s+the\s+tone/i, /no\s+estÃ¡?\s+disponible/i,
  /voicemail/i, /record\s+(your\s+)?message/i,
  /press(ione)?\s+\d/i, /marque\s+\d/i, /opci[oÃ³]n\s+\d/i,
  /para\s+.*\s+presione/i, /if\s+you\s+know\s+your\s+party/i,
  /mailbox\s+is\s+full/i, /deje(\s+su)?\s+mensaje/i,
  /al\s+escuchar\s+el\s+tono/i, /buz[oÃ³]n\s+de\s+voz/i,
  /please\s+leave\s+your\s+message/i, /not\s+available.*leave.*message/i
];

// Goodbye detection patterns
const GOODBYE_PATTERNS = [
  /you're welcome/i, /de nada/i,
  /have a (great|good|wonderful|nice) day/i, /que tengas? (un )?buen dÃ­a/i,
  /take care/i, /cuÃ­date/i,
  /goodbye/i, /adiÃ³s/i, /hasta luego/i,
  /if you need anything else/i, /si necesitas? algo mÃ¡s/i,
  /thanks for calling/i, /gracias por llamar/i,
  /bye/i, /chao/i
];

// Spam phone number patterns
const SPAM_PATTERNS = [
  /^1800/, /^1888/, /^1877/, /^1866/, /^1855/
];

// Tools that should never be deduplicated
const NEVER_DEDUP_TOOLS = [
  "send_message", "send_email", "send_sms", "send_sms_reminder",
  "schedule_appointment", "transfer_to_human", "end_call",
  "create_lead", "create_or_merge_contact", "take_note"
];

// ============================================================
// SECTION 2: UTILITIES
// ============================================================

/**
 * Logger - Structured logging with levels and context
 */
class Logger {
  constructor() {
    this.levels = { DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3, FATAL: 4 };
    this.currentLevel = this.levels[process.env.LOG_LEVEL || "INFO"];
  }

  _log(level, message, context = {}) {
    if (this.levels[level] < this.currentLevel) return;
    const logEntry = {
      timestamp: new Date().toISOString(),
      level,
      version: VERSION,
      message,
      ...context
    };
    const output = JSON.stringify(logEntry);
    if (level === "ERROR" || level === "FATAL") {
      console.error(output);
    } else {
      console.log(output);
    }
  }

  debug(message, context) { this._log("DEBUG", message, context); }
  info(message, context) { this._log("INFO", message, context); }
  warn(message, context) { this._log("WARN", message, context); }
  error(message, context) { this._log("ERROR", message, context); }
  fatal(message, context) { this._log("FATAL", message, context); }
}

const logger = new Logger();

/**
 * Validator - Input validation utilities
 */
class Validator {
  static isValidUUID(str) {
    if (!str || str === "undefined" || str === "null") return false;
    return /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(str);
  }

  static isValidPhone(phone) {
    if (!phone) return false;
    const normalized = String(phone).replace(/[^\d+]/g, "");
    return normalized.length >= 10 && normalized.length <= 15;
  }

  static isValidEmail(email) {
    if (!email) return false;
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  }

  static isValidLanguage(lang) {
    return lang && SUPPORTED_LANGUAGES.hasOwnProperty(lang);
  }

  static isValidVoice(voice) {
    return voice && VALID_OPENAI_VOICES.includes(voice.toLowerCase());
  }

  static sanitizeString(str, maxLength = 1000) {
    if (!str) return "";
    return String(str).substring(0, maxLength).trim();
  }
}

/**
 * Parser - Data parsing utilities
 */
class Parser {
  static safeJsonParse(str, fallback = null) {
    try {
      return JSON.parse(str);
    } catch {
      return fallback;
    }
  }

  static normalizePhone(phone) {
    if (!phone) return "";
    return String(phone).replace(/[^\d+]/g, "");
  }

  static decodeBase64Utf8(b64) {
    if (!b64 || typeof b64 !== "string") return null;
    try {
      if (!/^[A-Za-z0-9+/=]+$/.test(b64)) return b64;
      const binary = atob(b64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      const decoded = new TextDecoder("utf-8").decode(bytes);
      if (decoded.includes("\uFFFD") || /[\x00-\x08\x0B\x0C\x0E-\x1F]/.test(decoded)) {
        return b64;
      }
      if (decoded && decoded.length > 0) {
        logger.debug("Base64 decoded", { preview: decoded.substring(0, 80) });
        return decoded;
      }
    } catch (e) {
      logger.debug("Base64 decode failed", { error: e.message });
      return b64;
    }
    return null;
  }

  static normalizeUnicode(str) {
    if (!str) return str;
    const ranges = [
      { start: 0x1D400, end: 0x1D419, offset: 0x1D400 - 0x41 },
      { start: 0x1D41A, end: 0x1D433, offset: 0x1D41A - 0x61 },
      { start: 0x1D434, end: 0x1D44D, offset: 0x1D434 - 0x41 },
      { start: 0x1D44E, end: 0x1D467, offset: 0x1D44E - 0x61 },
      { start: 0x1D468, end: 0x1D481, offset: 0x1D468 - 0x41 },
      { start: 0x1D482, end: 0x1D49B, offset: 0x1D482 - 0x61 },
      { start: 0x1D49C, end: 0x1D4B5, offset: 0x1D49C - 0x41 },
      { start: 0x1D4B6, end: 0x1D4CF, offset: 0x1D4B6 - 0x61 },
      { start: 0x1D4D0, end: 0x1D4E9, offset: 0x1D4D0 - 0x41 },
      { start: 0x1D4EA, end: 0x1D503, offset: 0x1D4EA - 0x61 },
      { start: 0x1D5A0, end: 0x1D5B9, offset: 0x1D5A0 - 0x41 },
      { start: 0x1D5BA, end: 0x1D5D3, offset: 0x1D5BA - 0x61 },
      { start: 0x1D5D4, end: 0x1D5ED, offset: 0x1D5D4 - 0x41 },
      { start: 0x1D5EE, end: 0x1D607, offset: 0x1D5EE - 0x61 },
      { start: 0x1D670, end: 0x1D689, offset: 0x1D670 - 0x41 },
      { start: 0x1D68A, end: 0x1D6A3, offset: 0x1D68A - 0x61 }
    ];
    let normalized = "";
    for (const char of str) {
      const code = char.codePointAt(0);
      let found = false;
      for (const range of ranges) {
        if (code >= range.start && code <= range.end) {
          normalized += String.fromCharCode(code - range.offset);
          found = true;
          break;
        }
      }
      if (!found) normalized += char;
    }
    return normalized;
  }
}

/**
 * Utility functions
 */
function requireEnv(name, value) {
  if (!value) {
    logger.fatal("Missing required environment variable", { variable: name });
    throw new Error(`Missing required env: ${name}`);
  }
  return value;
}

function generatePrepId() {
  return `prep_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
}

function generateSessionId() {
  return `session_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
}

// Validate required environment variables
requireEnv("SUPABASE_URL", SUPABASE_URL);
requireEnv("SUPABASE_SERVICE_ROLE_KEY", SUPABASE_SERVICE_KEY);
requireEnv("OPENAI_API_KEY", OPENAI_API_KEY);

if (!VOICE_GATEWAY_TOKEN) {
  logger.warn("VOICE_GATEWAY_TOKEN not set â€” prewarm/sessions endpoints will be unprotected");
}

logger.info("Voice Gateway starting", {
  version: VERSION,
  port: PORT,
  webhooksEnabled: ENABLE_WEBHOOKS,
  metricsEnabled: ENABLE_METRICS,
  elevenLabsEnabled: !!ELEVENLABS_API_KEY
});

// ============================================================
// SECTION 3: RESILIENCE
// ============================================================

/**
 * RetryManager - Exponential backoff with jitter
 */
class RetryManager {
  static async execute(fn, options = {}) {
    const {
      maxRetries = MAX_RETRIES,
      baseDelay = BASE_RETRY_DELAY_MS,
      maxDelay = MAX_RETRY_DELAY_MS,
      retryableErrors = [500, 502, 503, 504, 429],
      context = {}
    } = options;

    let lastError;

    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        const result = await fn();
        if (attempt > 0) {
          logger.info("Retry succeeded", { ...context, attempt, maxRetries });
        }
        return result;
      } catch (error) {
        lastError = error;
        const isRetryable = this._isRetryable(error, retryableErrors);
        if (!isRetryable || attempt === maxRetries) {
          if (attempt > 0) {
            logger.error("Operation failed after retries", { ...context, attempt, error: error.message });
          }
          throw error;
        }
        const delay = Math.min(
          baseDelay * Math.pow(2, attempt) + Math.random() * 100,
          maxDelay
        );
        logger.warn("Retry scheduled", { ...context, attempt: attempt + 1, delayMs: Math.round(delay) });
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
    throw lastError;
  }

  static _isRetryable(error, retryableErrors) {
    if (error.status && retryableErrors.includes(error.status)) return true;
    if (["ECONNRESET", "ETIMEDOUT", "ECONNREFUSED"].includes(error.code)) return true;
    return false;
  }
}

/**
 * CircuitBreaker - Protect against cascading failures
 */
class CircuitBreaker {
  constructor(name, options = {}) {
    this.name = name;
    this.failureThreshold = options.failureThreshold || CIRCUIT_BREAKER_FAILURE_THRESHOLD;
    this.resetTimeout = options.resetTimeout || CIRCUIT_BREAKER_RESET_TIMEOUT_MS;
    this.state = "CLOSED";
    this.failures = 0;
    this.nextAttempt = Date.now();
    this.successCount = 0;
  }

  async execute(fn) {
    if (this.state === "OPEN") {
      if (Date.now() < this.nextAttempt) {
        const error = new Error(`Circuit breaker [${this.name}] is OPEN`);
        error.circuitOpen = true;
        throw error;
      }
      this.state = "HALF_OPEN";
      this.successCount = 0;
      logger.info("Circuit breaker attempting to close", { service: this.name, state: "HALF_OPEN" });
    }

    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  onSuccess() {
    this.failures = 0;
    if (this.state === "HALF_OPEN") {
      this.successCount++;
      if (this.successCount >= 2) {
        this.state = "CLOSED";
        logger.info("Circuit breaker closed", { service: this.name });
      }
    }
  }

  onFailure() {
    this.failures++;
    logger.warn("Circuit breaker failure recorded", {
      service: this.name, failures: this.failures, threshold: this.failureThreshold
    });
    if (this.failures >= this.failureThreshold) {
      this.state = "OPEN";
      this.nextAttempt = Date.now() + this.resetTimeout;
      logger.error("Circuit breaker opened", { service: this.name, resetInMs: this.resetTimeout });
    }
  }

  getState() {
    return { name: this.name, state: this.state, failures: this.failures, threshold: this.failureThreshold };
  }
}

// Initialize circuit breakers
const supabaseCircuit = new CircuitBreaker("Supabase", { failureThreshold: 3, resetTimeout: 30000 });
const openaiCircuit = new CircuitBreaker("OpenAI", { failureThreshold: 5, resetTimeout: 60000 });
const crmToolsCircuit = new CircuitBreaker("CRM_Tools", { failureThreshold: 5, resetTimeout: 60000 });
const elevenLabsCircuit = new CircuitBreaker("ElevenLabs", { failureThreshold: 3, resetTimeout: 60000 }); // NEW v7

/**
 * RateLimiter - Rate limiting per tenant and per IP
 */
class RateLimiter {
  static checkTenantLimit(companyId) {
    if (!companyId) return { allowed: false, reason: "No company ID" };

    const now = Date.now();
    if (!tenantCallCounts.has(companyId)) {
      tenantCallCounts.set(companyId, { concurrent: 0, hourly: [] });
    }
    const counts = tenantCallCounts.get(companyId);

    if (counts.concurrent >= RATE_LIMIT_CALLS_PER_TENANT_CONCURRENT) {
      return { allowed: false, reason: "Concurrent call limit exceeded", limit: RATE_LIMIT_CALLS_PER_TENANT_CONCURRENT };
    }

    counts.hourly = counts.hourly.filter(t => now - t < 3600000);
    if (counts.hourly.length >= RATE_LIMIT_CALLS_PER_TENANT_HOUR) {
      return { allowed: false, reason: "Hourly call limit exceeded", limit: RATE_LIMIT_CALLS_PER_TENANT_HOUR };
    }

    return { allowed: true };
  }

  static incrementTenantCalls(companyId) {
    if (!companyId) return;
    if (!tenantCallCounts.has(companyId)) {
      tenantCallCounts.set(companyId, { concurrent: 0, hourly: [] });
    }
    const counts = tenantCallCounts.get(companyId);
    counts.concurrent++;
    counts.hourly.push(Date.now());
  }

  static decrementTenantCalls(companyId) {
    if (!companyId) return;
    if (tenantCallCounts.has(companyId)) {
      const counts = tenantCallCounts.get(companyId);
      counts.concurrent = Math.max(0, counts.concurrent - 1);
    }
  }

  static checkIPLimit(ip) {
    if (!ip) return { allowed: true };
    const now = Date.now();
    if (!ipRequestCounts.has(ip)) {
      ipRequestCounts.set(ip, []);
    }
    const recentRequests = ipRequestCounts.get(ip).filter(t => now - t < 60000);
    ipRequestCounts.set(ip, recentRequests);
    if (recentRequests.length >= RATE_LIMIT_REQUESTS_PER_IP_MINUTE) {
      return { allowed: false, reason: "IP rate limit exceeded", limit: RATE_LIMIT_REQUESTS_PER_IP_MINUTE };
    }
    recentRequests.push(now);
    return { allowed: true };
  }
}

// ============================================================
// SECTION 4: STATE MANAGEMENT
// ============================================================

/**
 * SessionManager - Manage session lifecycle
 */
class SessionManager {
  static createSession(config = {}) {
    const sessionId = config.sessionId || generateSessionId();

    const session = {
      // Identifiers
      sessionId,
      callSid: config.callSid || null,
      prepId: config.prepId || null,

      // Configuration
      companyId: config.companyId,
      agentId: config.agentId,
      config: config.agentConfig || null,

      // Call state
      direction: config.direction || "inbound",
      fromNumber: config.fromNumber || "",
      toNumber: config.toNumber || "",
      customerPhone: config.customerPhone || "",
      language: config.language || DEFAULT_LANGUAGE,

      // Connections
      twilioWs: null,
      openaiWs: null,
      streamSid: null,

      // Conversational state
      transcripts: { user: [], assistant: [] },
      toolCalls: [],
      toolCallLog: [],  // NEW v7: persistent tool call log
      preloadedContact: config.preloadedContact || null,
      dynamicInstructions: config.dynamicInstructions || null,
      dynamicInstructionsMode: config.dynamicInstructionsMode || "addon",
      dynamicFirstMessage: config.dynamicFirstMessage || null,

      // NEW v7: Dynamic tools and playbook
      dynamicTools: null,
      playbook: null,

      // NEW v7: Agent extended config
      agentExtendedConfig: null,

      // Flags
      sessionCreated: false,
      sessionReady: false,
      twilioStreamReady: false,
      callEnding: false,
      greetingMessageSent: false,
      greetingTriggered: false,
      voicemailHandled: false,
      firstAudioSent: false,
      skipGreeting: config.skipGreeting || false,
      isDemoCall: config.isDemoCall || false,
      configReady: false,
      pendingSessionUpdate: false,

      // Response locking
      responseLock: { isLocked: false, lockedBy: null, lockedAt: null },

      // Timers
      autoHangupTimer: null,
      greetingTimer: null,
      ringbackInterval: null,
      ringbackFrames: 0,

      // Metrics
      metrics: {
        t_session_created: Date.now(),
        t_openai_connected: null,
        t_config_loaded: null,
        t_session_ready: null,
        t_stream_start: null,
        t_first_audio_sent: null,
        t_call_ended: null
      },

      // Metadata
      createdAt: Date.now(),
      updatedAt: Date.now()
    };

    sessions.set(sessionId, session);

    logger.info("Session created", {
      sessionId, callSid: session.callSid,
      companyId: session.companyId, direction: session.direction
    });

    return session;
  }

  static getSession(sessionId) {
    return sessions.get(sessionId);
  }

  static getSessionByCallSid(callSid) {
    for (const [, session] of sessions.entries()) {
      if (session.callSid === callSid) return session;
    }
    return null;
  }

  static deleteSession(sessionId) {
    const session = sessions.get(sessionId);
    if (session) {
      if (session.autoHangupTimer) clearTimeout(session.autoHangupTimer);
      if (session.greetingTimer) clearTimeout(session.greetingTimer);
      if (session.ringbackInterval) clearInterval(session.ringbackInterval);
      if (session.companyId) {
        RateLimiter.decrementTenantCalls(session.companyId);
      }
      // NEW v7: Persist tool call logs before deleting
      ToolCallLogger.persist(session).catch(e =>
        logger.error("Tool log persist failed on delete", { error: e.message })
      );
      sessions.delete(sessionId);
      logger.info("Session deleted", {
        sessionId, callSid: session.callSid,
        durationMs: Date.now() - session.createdAt
      });
    }
  }

  static getActiveSessionCount() {
    return sessions.size;
  }

  static getPrewarmSessionCount() {
    return prewarmSessions.size;
  }
}

/**
 * ResponseLockManager - Prevent concurrent OpenAI responses
 */
class ResponseLockManager {
  static init(session) {
    session.responseLock = { isLocked: false, lockedBy: null, lockedAt: null };
  }

  static tryLock(session, reason) {
    if (!session.responseLock) this.init(session);
    if (session.responseLock.isLocked) return false;
    session.responseLock = { isLocked: true, lockedBy: reason, lockedAt: Date.now() };
    return true;
  }

  static unlock(session, reason) {
    if (session.responseLock?.isLocked) {
      const dur = Date.now() - (session.responseLock.lockedAt || Date.now());
      logger.debug("Response unlocked", { reason, durationMs: dur });
    }
    if (session.responseLock) {
      session.responseLock.isLocked = false;
      session.responseLock.lockedBy = null;
    }
  }

  static sendResponseCreateSafe(session, payload, reason) {
    if (session.callEnding) return false;
    if (!this.tryLock(session, "response.create:" + reason)) return false;
    if (session.openaiWs?.readyState === WebSocket.OPEN) {
      session.openaiWs.send(JSON.stringify(payload));
      return true;
    }
    return false;
  }
}

/**
 * Prewarm session management
 */
function createPrewarmSession(agentId, companyId, config) {
  const prepId = generatePrepId();
  const prewarmData = {
    prepId, agentId, companyId, config,
    openaiWs: null,
    sessionCreated: false,
    sessionReady: false,
    createdAt: Date.now(),
    expiresAt: Date.now() + PREWARM_SESSION_TTL_MS
  };
  prewarmSessions.set(prepId, prewarmData);
  logger.info("Prewarm session created", { prepId, agentId, companyId });
  return prewarmData;
}

function getPrewarmSession(agentId, companyId) {
  const now = Date.now();
  for (const [prepId, prewarm] of prewarmSessions.entries()) {
    if (prewarm.agentId === agentId &&
      prewarm.companyId === companyId &&
      prewarm.sessionReady &&
      prewarm.expiresAt > now) {
      prewarmSessions.delete(prepId);
      logger.info("Prewarm session reused", { prepId, agentId, ageMs: now - prewarm.createdAt });
      return prewarm;
    }
  }
  return null;
}

function cleanupExpiredPrewarmSessions() {
  const now = Date.now();
  let cleaned = 0;
  for (const [prepId, prewarm] of prewarmSessions.entries()) {
    if (prewarm.expiresAt <= now) {
      if (prewarm.openaiWs) {
        prewarm.openaiWs.close(1000, "prewarm_expired");
      }
      prewarmSessions.delete(prepId);
      cleaned++;
    }
  }
  if (cleaned > 0) {
    logger.info("Prewarm sessions cleaned", { count: cleaned });
  }
}

setInterval(cleanupExpiredPrewarmSessions, PREWARM_CLEANUP_INTERVAL_MS);

// ============================================================
// SECTION 5: EXTERNAL SERVICES
// ============================================================

/**
 * SupabaseClient - Interact with Supabase REST API (with Circuit Breaker + Retry)
 */
class SupabaseClient {
  static async request(endpoint, method = "GET", body = null, prefer = null) {
    const url = `${SUPABASE_URL}/rest/v1/${endpoint}`;
    const headers = {
      "apikey": SUPABASE_SERVICE_KEY,
      "Authorization": `Bearer ${SUPABASE_SERVICE_KEY}`,
      "Content-Type": "application/json"
    };
    if (prefer) headers["Prefer"] = prefer;
    const options = { method, headers };
    if (body) options.body = JSON.stringify(body);
    const context = { endpoint, method };

    try {
      const response = await supabaseCircuit.execute(async () => {
        return await RetryManager.execute(
          async () => {
            const res = await fetch(url, options);
            if (!res.ok) {
              const error = new Error(`Supabase error: ${res.status}`);
              error.status = res.status;
              throw error;
            }
            return res;
          },
          { context }
        );
      });
      const text = await response.text();
      const data = text ? Parser.safeJsonParse(text, text) : null;
      return { ok: true, status: response.status, data };
    } catch (error) {
      logger.error("Supabase request failed", {
        endpoint, method, error: error.message, circuitOpen: error.circuitOpen || false
      });
      return { ok: false, status: error.status || 0, data: null, error: error.message };
    }
  }

  static async insertReturning(table, row) {
    const res = await this.request(table, "POST", row, "return=representation");
    if (!res.ok) return null;
    return Array.isArray(res.data) ? res.data[0] : res.data;
  }

  /**
   * Multi-source agent config loader: agents_new â†’ autoprompt â†’ ai_agents â†’ bc_agents
   * ENHANCED v7: Also loads ai_model, ai_temperature, ai_max_tokens, stt_*, voice_provider, elevenlabs_* from bc_agents
   */
  static async loadAgentConfig(agentId, companyId) {
    const cacheKey = agentId + "_" + (companyId || "");
    const cached = agentConfigCache.get(cacheKey);
    if (cached && Date.now() - cached._ts < 300000) return cached;

    logger.info("Loading agent config", { agentId, companyId });

    const config = {
      agentId, companyId,
      voice: DEFAULT_VOICE,
      systemPrompt: "You are a helpful assistant.",
      firstMessage: null,
      language: DEFAULT_LANGUAGE,
      companyName: null,
      companyTimezone: DEFAULT_TIMEZONE,
      humanAgents: [],
      webhook_url: null,
      // NEW v7 fields
      voiceProvider: "openai",
      elevenlabsVoiceId: null,
      elevenlabsStability: 0.5,
      elevenlabsSimilarityBoost: 0.75,
      elevenlabsStyle: 0.0,
      elevenlabsSpeed: 1.0,
      elevenlabsModelId: "eleven_turbo_v2_5",
      aiModel: OPENAI_REALTIME_MODEL,
      aiTemperature: 0.8,
      aiMaxTokens: 4096,
      sttProvider: "openai",
      sttLanguage: "es",
      sttModel: "whisper-1",
      _ts: Date.now()
    };

    try {
      // 1. Try agents_new (production agents)
      const agentRes = await this.request("agents_new?id=eq." + agentId + "&select=*");
      if (agentRes.ok && agentRes.data?.[0]) {
        const agent = agentRes.data[0];
        config.voice = VoiceMapper.mapToOpenAI(agent.elevenlabs_voice || agent.tts_voice || agent.voice_id);
        config.language = agent.language_preference || DEFAULT_LANGUAGE;
        config.companyName = agent.company_name;
        config.companyId = agent.company_id || companyId;
      }

      // 2. Load autoprompt (highest priority for system prompt)
      const autopromptRes = await this.request("agent_autoprompt?agent_id=eq." + agentId + "&select=*");
      if (autopromptRes.ok && autopromptRes.data?.[0]) {
        const ap = autopromptRes.data[0];
        config.systemPrompt = ap.system_prompt || config.systemPrompt;
        config.firstMessage = ap.first_message;
        if (ap.languages?.length > 0) config.language = ap.languages[0];
      }

      // 3. Fallback to ai_agents
      if (config.systemPrompt === "You are a helpful assistant.") {
        const aiRes = await this.request("ai_agents?agent_id=eq." + agentId + "&select=*");
        if (aiRes.ok && aiRes.data?.[0]) {
          config.systemPrompt = aiRes.data[0].system_prompt || config.systemPrompt;
          config.firstMessage = config.firstMessage || aiRes.data[0].first_message;
        }
      }

      // 4. Try bc_agents (Blue Core sandbox) â€” ENHANCED v7 with extended fields
      if (config.systemPrompt === "You are a helpful assistant.") {
        const bcRes = await this.request("bc_agents?id=eq." + agentId + "&select=*");
        if (bcRes.ok && bcRes.data?.[0]) {
          const bcAgent = bcRes.data[0];
          config.systemPrompt = bcAgent.system_prompt_base || config.systemPrompt;
          config.voice = VoiceMapper.mapToOpenAI(bcAgent.openai_voice || bcAgent.voice_provider || DEFAULT_VOICE);
          config.language = bcAgent.language_default || bcAgent.language || config.language;
          config.firstMessage = config.firstMessage || bcAgent.first_message;

          // NEW v7: Extended bc_agents fields
          config.voiceProvider = bcAgent.voice_provider || bcAgent.tts_provider || "openai";
          config.elevenlabsVoiceId = bcAgent.elevenlabs_voice_id || bcAgent.tts_voice || null;
          config.elevenlabsStability = bcAgent.elevenlabs_stability ?? 0.5;
          config.elevenlabsSimilarityBoost = bcAgent.elevenlabs_similarity_boost ?? 0.75;
          config.elevenlabsStyle = bcAgent.elevenlabs_style ?? 0.0;
          config.elevenlabsSpeed = bcAgent.elevenlabs_speed ?? 1.0;
          config.elevenlabsModelId = bcAgent.elevenlabs_model_id || "eleven_turbo_v2_5";
          config.aiModel = bcAgent.ai_model || OPENAI_REALTIME_MODEL;
          config.aiTemperature = bcAgent.ai_temperature ?? 0.8;
          config.aiMaxTokens = bcAgent.ai_max_tokens ?? 4096;
          config.sttProvider = bcAgent.stt_provider || "openai";
          config.sttLanguage = bcAgent.stt_language || config.language;
          config.sttModel = bcAgent.stt_model || "whisper-1";

          logger.info("Agent loaded from bc_agents", {
            agentId,
            voiceProvider: config.voiceProvider,
            aiModel: config.aiModel,
            sttProvider: config.sttProvider
          });
        }
      }

      // 5. Load company (try companies, then bc_companies)
      const effectiveCompanyId = config.companyId || companyId;
      if (effectiveCompanyId) {
        const companyRes = await this.request("companies?id=eq." + effectiveCompanyId + "&select=name,timezone");
        if (companyRes.ok && companyRes.data?.[0]) {
          config.companyName = config.companyName || companyRes.data[0].name;
          config.companyTimezone = companyRes.data[0].timezone || DEFAULT_TIMEZONE;
        }
        if (!config.companyName) {
          const bcCompRes = await this.request("bc_companies?id=eq." + effectiveCompanyId + "&select=name");
          if (bcCompRes.ok && bcCompRes.data?.[0]) {
            config.companyName = bcCompRes.data[0].name;
            logger.info("Company loaded from bc_companies", { companyId: effectiveCompanyId });
          }
        }

        // 6. Load human agents for transfer
        const humanRes = await this.request("agents_new?company_id=eq." + effectiveCompanyId + "&type=eq.human&status=eq.active&select=id,display_name");
        if (humanRes.ok && humanRes.data) {
          config.humanAgents = humanRes.data.map(a => ({ id: a.id, name: a.display_name }));
        }
      }
    } catch (e) {
      logger.error("Agent config load error", { agentId, error: e.message });
    }

    agentConfigCache.set(cacheKey, config);
    return config;
  }

  /**
   * Load prep session from DB: call_prep_sessions â†’ bc_call_prep_sessions
   */
  static async loadPrepSession(prepId, session) {
    logger.info("Loading prep session from DB", { prepId });
    try {
      // Try production call_prep_sessions
      const res = await this.request("call_prep_sessions?prep_id=eq." + prepId + "&select=*");
      if (res.ok && res.data?.[0]) {
        const prep = res.data[0];
        session.dynamicInstructions = prep.dynamic_instructions || session.dynamicInstructions;
        session.language = prep.language || session.language;
        if (prep.dynamic_instructions_mode) session.dynamicInstructionsMode = prep.dynamic_instructions_mode;
        if (prep.first_message) session.dynamicFirstMessage = prep.first_message;
        if (prep.contact_name) {
          session.preloadedContact = session.preloadedContact || {};
          session.preloadedContact.name = prep.contact_name;
          session.preloadedContact.safeName = BusinessNameDetector.getSafeContactName(prep.contact_name);
        }
        logger.info("Prep loaded from call_prep_sessions", { prepId, hasInstructions: !!session.dynamicInstructions });
        return;
      }

      // Fallback: Blue Core bc_call_prep_sessions
      const bcRes = await this.request("bc_call_prep_sessions?id=eq." + prepId + "&select=*");
      if (bcRes.ok && bcRes.data?.[0]) {
        const bcPrep = bcRes.data[0];
        session.dynamicInstructions = bcPrep.dynamic_instructions || session.dynamicInstructions;
        session.language = bcPrep.language || session.language;
        if (bcPrep.first_message) session.dynamicFirstMessage = bcPrep.first_message;
        logger.info("Prep loaded from bc_call_prep_sessions", { prepId });
      }
    } catch (e) {
      logger.error("Prep session load error", { prepId, error: e.message });
    }
  }
}

/**
 * CRMToolsClient - Execute CRM tools via Edge Function
 */
class CRMToolsClient {
  static async executeTool(toolName, args, context) {
    const payload = {
      tool_name: toolName,
      arguments: args,
      context: {
        company_id: context.companyId,
        agent_id: context.agentId,
        call_sid: context.callSid,
        customer_phone: context.customerPhone || "",
        direction: context.direction || "inbound"
      }
    };

    const requestContext = { toolName, callSid: context.callSid };

    try {
      const response = await crmToolsCircuit.execute(async () => {
        return await RetryManager.execute(
          async () => {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), TOOL_EXECUTION_TIMEOUT_MS);
            try {
              const res = await fetch(CRM_TOOLS_URL, {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  "Authorization": `Bearer ${SUPABASE_SERVICE_KEY}`
                },
                body: JSON.stringify(payload),
                signal: controller.signal
              });
              clearTimeout(timeout);
              if (!res.ok) {
                const error = new Error(`CRM Tools error: ${res.status}`);
                error.status = res.status;
                throw error;
              }
              return res;
            } catch (error) {
              clearTimeout(timeout);
              throw error;
            }
          },
          { context: requestContext }
        );
      });

      const data = await response.json();
      logger.info("CRM tool executed", { toolName, callSid: context.callSid, success: data.success !== false });
      return data;
    } catch (error) {
      logger.error("CRM tool execution failed", {
        toolName, callSid: context.callSid, error: error.message, circuitOpen: error.circuitOpen || false
      });
      return { success: false, error: error.message, fallback: "Tool execution failed. Please try again." };
    }
  }
}

/**
 * WebhookClient - Send post-call webhooks
 */
class WebhookClient {
  static async send(url, payload) {
    if (!ENABLE_WEBHOOKS || !url) return;

    try {
      await RetryManager.execute(
        async () => {
          const controller = new AbortController();
          const timeout = setTimeout(() => controller.abort(), WEBHOOK_TIMEOUT_MS);
          try {
            const res = await fetch(url, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
              signal: controller.signal
            });
            clearTimeout(timeout);
            if (!res.ok) {
              throw new Error(`Webhook failed: ${res.status}`);
            }
            logger.info("Webhook sent", { url, callSid: payload.call_sid });
          } catch (error) {
            clearTimeout(timeout);
            throw error;
          }
        },
        { maxRetries: 2, context: { webhook: url } }
      );
    } catch (error) {
      logger.error("Webhook failed after retries", { url, error: error.message });
    }
  }
}

// ============================================================
// SECTION 5B: NEW v7 EXTERNAL SERVICES
// ============================================================

/**
 * ElevenLabsTTSClient - Text-to-Speech via ElevenLabs API (NEW v7)
 */
class ElevenLabsTTSClient {
  static async synthesize(text, config = {}) {
    const {
      voiceId = "JBFqnCBsd6RMkjVDRZzb",
      stability = 0.5,
      similarityBoost = 0.75,
      style = 0.0,
      speed = 1.0,
      modelId = "eleven_turbo_v2_5"
    } = config;

    if (!ELEVENLABS_API_KEY) {
      throw new Error("ELEVENLABS_API_KEY not configured");
    }

    const url = `https://api.elevenlabs.io/v1/text-to-speech/${voiceId}?output_format=ulaw_8000`;

    const response = await elevenLabsCircuit.execute(async () => {
      return await RetryManager.execute(async () => {
        const res = await fetch(url, {
          method: "POST",
          headers: {
            "xi-api-key": ELEVENLABS_API_KEY,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            text,
            model_id: modelId,
            voice_settings: {
              stability,
              similarity_boost: similarityBoost,
              style,
              use_speaker_boost: true,
              speed
            }
          })
        });
        if (!res.ok) {
          const errText = await res.text();
          const error = new Error(`ElevenLabs TTS error ${res.status}: ${errText}`);
          error.status = res.status;
          throw error;
        }
        return res;
      }, { context: { service: "ElevenLabs TTS" } });
    });

    const arrayBuf = await response.arrayBuffer();
    return Buffer.from(arrayBuf);
  }
}

/**
 * DynamicToolLoader - Load tool schemas from bc_agent_tools (NEW v7)
 */
class DynamicToolLoader {
  static cache = new Map();

  static async loadTools(agentId) {
    const cached = this.cache.get(agentId);
    if (cached && Date.now() - cached.loadedAt < TOOL_CACHE_TTL_MS) {
      return cached.tools;
    }

    try {
      const res = await SupabaseClient.request(
        `bc_agent_tools?agent_id=eq.${agentId}&enabled=eq.true&order=priority.asc&select=*`
      );

      if (!res.ok || !res.data?.length) {
        logger.info("[DynamicToolLoader] No dynamic tools found, using defaults", { agentId });
        return null; // null = use hardcoded defaults
      }

      const tools = res.data.map(t => ({
        name: t.tool_name,
        type: t.tool_type || "function",
        schema: t.schema || null,
        config: t.config || {},
        handlerConfig: t.handler_config || {},
        priority: t.priority || 0
      }));

      this.cache.set(agentId, { tools, loadedAt: Date.now() });
      logger.info("[DynamicToolLoader] Loaded tools from DB", { agentId, count: tools.length });
      return tools;
    } catch (err) {
      logger.error("[DynamicToolLoader] Load failed", { agentId, error: err.message });
      return null;
    }
  }

  static invalidateCache(agentId) {
    if (agentId) {
      this.cache.delete(agentId);
    } else {
      this.cache.clear();
    }
  }
}

/**
 * PlaybookLoader - Load playbooks from bc_agent_playbooks (NEW v7)
 */
class PlaybookLoader {
  static cache = new Map();

  static async loadPlaybook(agentId, language = "es") {
    const cacheKey = `${agentId}:${language}`;
    const cached = this.cache.get(cacheKey);
    if (cached && Date.now() - cached.loadedAt < PLAYBOOK_CACHE_TTL_MS) {
      return cached.playbook;
    }

    try {
      // Try language-specific first
      let res = await SupabaseClient.request(
        `bc_agent_playbooks?agent_id=eq.${agentId}&is_active=eq.true&language=eq.${language}&order=version.desc&limit=1&select=*`
      );

      let playbookRow = res.ok && res.data?.[0] ? res.data[0] : null;

      // Fallback: any active playbook
      if (!playbookRow) {
        res = await SupabaseClient.request(
          `bc_agent_playbooks?agent_id=eq.${agentId}&is_active=eq.true&order=version.desc&limit=1&select=*`
        );
        playbookRow = res.ok && res.data?.[0] ? res.data[0] : null;
      }

      if (!playbookRow) {
        logger.info("[PlaybookLoader] No active playbook found", { agentId });
        return null;
      }

      const playbook = {
        openingScript: playbookRow.opening_script || "",
        qualifyingQuestions: playbookRow.qualifying_questions || [],
        objectionHandlers: playbookRow.objection_handlers || [],
        valueProps: playbookRow.value_props || [],
        ctaLinks: playbookRow.cta_links || [],
        planRules: playbookRow.plan_rules || [],
        language: playbookRow.language || "es",
        version: playbookRow.version || 1
      };

      this.cache.set(cacheKey, { playbook, loadedAt: Date.now() });
      logger.info("[PlaybookLoader] Loaded playbook", { agentId, language, version: playbook.version });
      return playbook;
    } catch (err) {
      logger.error("[PlaybookLoader] Load failed", { agentId, error: err.message });
      return null;
    }
  }

  static invalidateCache(agentId) {
    if (agentId) {
      for (const key of this.cache.keys()) {
        if (key.startsWith(agentId)) this.cache.delete(key);
      }
    } else {
      this.cache.clear();
    }
  }
}

/**
 * ToolCallLogger - Persist tool call logs to bc_call_prep_sessions (NEW v7)
 */
class ToolCallLogger {
  static record(session, toolName, args, result, durationMs) {
    if (!session.toolCallLog) session.toolCallLog = [];
    session.toolCallLog.push({
      tool_name: toolName,
      arguments: args,
      result: result,
      status: result?.success !== false ? "success" : "error",
      duration_ms: durationMs,
      timestamp: new Date().toISOString()
    });
  }

  static async persist(session) {
    if (!session.prepId || !session.toolCallLog?.length) return;

    try {
      // Try bc_call_prep_sessions first
      const res = await SupabaseClient.request(
        `bc_call_prep_sessions?id=eq.${session.prepId}`,
        "PATCH",
        { tool_calls_log: session.toolCallLog }
      );
      if (res.ok) {
        logger.info("[ToolCallLogger] Persisted tool logs", {
          prepId: session.prepId,
          count: session.toolCallLog.length
        });
      }
    } catch (err) {
      logger.error("[ToolCallLogger] Persist failed", { error: err.message });
    }
  }
}

// ============================================================
// SECTION 6: BUSINESS LOGIC
// ============================================================

/**
 * BusinessNameDetector - Detect and filter business/placeholder names
 */
class BusinessNameDetector {
  static INDICATORS = [
    "llc", "inc", "corp", "corporation", "ltd", "limited", "co", "company", "enterprises",
    "holdings", "shop", "salon", "restaurant", "store", "studio", "garage", "clinic",
    "office", "agency", "group", "market", "services", "solutions", "consulting",
    "associates", "partners", "industries", "construction", "plumbing", "electric",
    "auto", "automotive", "trucking", "transport", "cleaning", "landscaping", "roofing",
    "hvac", "flooring", "painting", "remodeling", "barbershop", "barber", "hair", "nails",
    "spa", "beauty", "fitness", "gym", "dental", "medical", "law", "legal",
    "homes", "home", "signature", "network", "grill", "bar", "cafe", "coffee", "pizza",
    "tacos", "food", "express", "delivery", "moving", "movers", "storage", "rental",
    "academy", "school", "training", "center", "centre", "club", "foundation",
    "taller", "tienda", "peluquerÃ­a", "barberÃ­a", "restaurante", "clÃ­nica", "estudio",
    "servicios", "constructora", "mecÃ¡nica", "carpinterÃ­a", "panaderÃ­a",
    "dominicanos", "mexicanos", "latinos", "hispanos",
    "the ", " & ", " and ", " y ", "realty", "real estate", "insurance",
    "marketing", "media", "design", "tech", "technology", "digital", "professional"
  ];

  static PATTERNS = [/\|/, /\b(rd|llc|inc|corp)\b/i, /\d{3,}/, /^[A-Z\s&]+$/];

  static PLACEHOLDER_NAMES = [
    "unknown", "desconocido", "anÃ³nimo", "anonimo", "anonymous",
    "null", "undefined", "n/a", "na", "none", "no name", "sin nombre",
    "cliente", "customer", "user", "usuario", "contact", "contacto",
    "no disponible", "not available", "pending", "pendiente"
  ];

  static isBusinessName(name) {
    if (!name || typeof name !== "string" || name.trim().length === 0) return false;
    const normalized = Parser.normalizeUnicode(name);
    const lower = normalized.toLowerCase().trim();
    for (const ind of this.INDICATORS) { if (lower.includes(ind)) return true; }
    for (const pat of this.PATTERNS) { if (pat.test(normalized)) return true; }
    if (normalized === normalized.toUpperCase() && normalized.length > 5 && normalized.includes(" ") && !/[a-z]/.test(normalized)) return true;
    return false;
  }

  static getSafeContactName(name) {
    if (!name || typeof name !== "string") return null;
    const trimmed = name.trim();
    if (trimmed.length === 0) return null;
    const lower = trimmed.toLowerCase();
    if (this.PLACEHOLDER_NAMES.includes(lower)) return null;
    const prefixes = ["unknown", "desconocido", "anon", "cliente #", "customer #", "lead #"];
    for (const p of prefixes) { if (lower.startsWith(p)) return null; }
    if (this.isBusinessName(trimmed)) return null;
    return trimmed;
  }
}

/**
 * LanguageDetector - Automatic language detection
 */
class LanguageDetector {
  static detect(text) {
    if (!text || text.length < 5) return null;

    const scores = {};
    for (const [lang, config] of Object.entries(SUPPORTED_LANGUAGES)) {
      scores[lang] = 0;
      for (const pattern of config.patterns) {
        if (pattern.test(text)) scores[lang]++;
      }
    }

    let maxScore = 0;
    let detectedLang = null;
    for (const [lang, score] of Object.entries(scores)) {
      if (score > maxScore) { maxScore = score; detectedLang = lang; }
    }

    if (maxScore < 1) return null;

    logger.debug("Language detected", { text: text.substring(0, 50), detected: detectedLang, score: maxScore });
    return detectedLang;
  }

  static async updateSessionLanguage(session, newLanguage) {
    if (!Validator.isValidLanguage(newLanguage)) return false;
    if (session.language === newLanguage) return false;

    const oldLanguage = session.language;
    session.language = newLanguage;
    logger.info("Language changed", { callSid: session.callSid, from: oldLanguage, to: newLanguage });

    if (session.sessionReady && session.openaiWs && session.config) {
      OpenAIHandler.sendSessionUpdate(session);
    }
    return true;
  }
}

/**
 * VoicemailDetector - Detect voicemail and IVR systems
 */
class VoicemailDetector {
  static detect(text) {
    if (!text || text.length < 10) return false;
    return VOICEMAIL_PATTERNS.some(p => p.test(text));
  }

  static async handleDetection(session) {
    if (session.voicemailHandled) return;
    session.voicemailHandled = true;

    logger.warn("Voicemail detected", { callSid: session.callSid });

    try {
      await CRMToolsClient.executeTool(
        "end_call",
        {
          reason: "voicemail_detected", outcome: "voicemail",
          phone: session.customerPhone || "",
          contactName: session.preloadedContact?.name || "",
          goodbye_message: ""
        },
        { companyId: session.companyId, agentId: session.agentId, callSid: session.callSid }
      );
    } catch (error) {
      logger.error("Voicemail handler error", { callSid: session.callSid, error: error.message });
    }

    session.callEnding = true;
    setTimeout(() => {
      if (session.openaiWs?.readyState === WebSocket.OPEN) session.openaiWs.close(1000, "voicemail");
      setTimeout(() => {
        if (session.twilioWs?.readyState === WebSocket.OPEN) session.twilioWs.close(1000, "voicemail");
      }, 500);
    }, 500);
  }
}

/**
 * AutoHangupManager - Manage automatic call termination
 */
class AutoHangupManager {
  static checkForGoodbye(session, transcript) {
    if (!transcript || session.callEnding) return;

    if (!session.greetingMessageSent) {
      session.greetingMessageSent = true;
      logger.debug("Skipping goodbye check on first message", { callSid: session.callSid });
      return;
    }

    if (GOODBYE_PATTERNS.some(p => p.test(transcript))) {
      logger.info("Goodbye pattern detected", { callSid: session.callSid, transcript: transcript.substring(0, 50) });
      this.scheduleHangup(session);
    }
  }

  static scheduleHangup(session) {
    if (session.autoHangupTimer) clearTimeout(session.autoHangupTimer);

    session.autoHangupTimer = setTimeout(() => {
      if (!session.callEnding) {
        logger.info("Auto-hangup triggered", { callSid: session.callSid });
        session.callEnding = true;
        if (session.openaiWs?.readyState === WebSocket.OPEN) session.openaiWs.close(1000, "auto_hangup");
        setTimeout(() => {
          if (session.twilioWs?.readyState === WebSocket.OPEN) session.twilioWs.close(1000, "auto_hangup");
        }, 500);
      }
    }, AUTO_HANGUP_TIMEOUT_MS);
  }

  static cancelHangup(session) {
    if (session.autoHangupTimer) {
      clearTimeout(session.autoHangupTimer);
      session.autoHangupTimer = null;
      logger.debug("Auto-hangup cancelled", { callSid: session.callSid });
    }
  }
}

/**
 * SpamFilter - Filter spam and sales calls
 */
class SpamFilter {
  static isSpamNumber(phone) {
    if (!phone) return false;
    const normalized = Parser.normalizePhone(phone);
    return SPAM_PATTERNS.some(pattern => pattern.test(normalized));
  }

  static shouldBlockCall(fromNumber) {
    if (this.isSpamNumber(fromNumber)) {
      logger.info("Spam number blocked", { fromNumber });
      return { blocked: true, reason: "Spam number detected" };
    }
    return { blocked: false };
  }
}

/**
 * ToolDeduplicator - Prevent duplicate tool executions
 */
class ToolDeduplicator {
  static shouldExecute(session, toolName, args) {
    if (NEVER_DEDUP_TOOLS.includes(toolName)) return { shouldExecute: true };

    const recentCalls = (session.toolCalls || []).filter(
      call => Date.now() - (call.timestamp || call.ts) < 10000
    );

    for (const call of recentCalls) {
      if (call.name === toolName && JSON.stringify(call.args) === JSON.stringify(args)) {
        logger.warn("Duplicate tool call blocked", {
          callSid: session.callSid, toolName,
          lastCallAgo: Date.now() - (call.timestamp || call.ts)
        });
        return { shouldExecute: false, reason: "Duplicate call detected", previousResult: call.result };
      }
    }
    return { shouldExecute: true };
  }

  static recordExecution(session, toolName, args, result) {
    if (!session.toolCalls) session.toolCalls = [];
    session.toolCalls.push({ name: toolName, args, result, timestamp: Date.now() });
    if (session.toolCalls.length > 20) session.toolCalls = session.toolCalls.slice(-20);
  }
}

/**
 * PromptBuilder - Build enhanced prompts with dynamic instruction support
 * ENHANCED v7: Now injects playbook data (opening_script, qualifying_questions, objection_handlers)
 */
class PromptBuilder {
  static build(session, config) {
    // Full dynamic mode â€” replace entire prompt
    if (session.dynamicInstructions && session.dynamicInstructionsMode === "full") {
      // NEW v7: Even in full mode, append playbook if available
      let prompt = session.dynamicInstructions;
      if (session.playbook) {
        prompt += "\n\n" + this._buildPlaybookSection(session.playbook);
      }
      return prompt;
    }

    const isOutbound = session.direction === "outbound";
    const customerPhone = session.customerPhone || session.fromNumber || session.toNumber || "";
    const primaryLang = (session.language || config.language || DEFAULT_LANGUAGE) === "en" ? "English" : "Spanish";
    const secondaryLang = primaryLang === "English" ? "Spanish" : "English";
    const safeName = session.preloadedContact ? BusinessNameDetector.getSafeContactName(session.preloadedContact.name) : null;

    const parts = [];

    // Language configuration
    parts.push("## MANDATORY LANGUAGE CONFIGURATION");
    parts.push(`PRIMARY LANGUAGE: ${primaryLang.toUpperCase()}`);
    parts.push(`Start and continue in ${primaryLang}. Only switch if customer speaks ${secondaryLang} first.`);
    parts.push("");

    // Demo mode
    if (session.isDemoCall) {
      parts.push("## DEMO MODE â€” NO SCHEDULING");
      parts.push("Redirect to self-serve signup link instead.");
      parts.push("");
    }

    // Dynamic instructions (addon mode)
    if (session.dynamicInstructions && session.dynamicInstructionsMode !== "full") {
      parts.push("## DYNAMIC INSTRUCTIONS (PRIORITY)");
      parts.push(session.dynamicInstructions);
      parts.push("");
    }

    // Base system prompt
    parts.push(config.systemPrompt || "You are a helpful assistant.");
    parts.push("");

    // NEW v7: Playbook injection
    if (session.playbook) {
      parts.push(this._buildPlaybookSection(session.playbook));
      parts.push("");
    }

    // Call direction
    if (isOutbound) {
      parts.push("CALL DIRECTION: OUTBOUND â€” YOU initiated this call. Do NOT ask 'how can I help you?'");
    } else {
      parts.push("CALL DIRECTION: INBOUND â€” Customer called YOU. Greet and ask how you can help.");
    }

    // Contact info
    if (safeName) {
      parts.push(`\nCUSTOMER: ${safeName} (Phone: ${customerPhone})`);
    } else if (customerPhone) {
      parts.push(`\nAfter greeting, call lookup_contact with phone ${customerPhone}.`);
    }

    // CRM rules
    let crmRules = "\nCRM RULES: Identify contact â†’ create_lead if interest â†’ ";
    if (!session.isDemoCall) crmRules += "schedule_appointment if requested â†’ ";
    crmRules += "take_note before ending.";
    parts.push(crmRules);

    // Human agents
    if (config.humanAgents?.length) {
      parts.push("\nHuman agents: " + config.humanAgents.map(a => a.name).join(", "));
    }

    // Timezone
    parts.push(`\nTIMEZONE: ${config.companyTimezone || DEFAULT_TIMEZONE}`);

    return parts.join("\n");
  }

  /**
   * NEW v7: Build playbook section for prompt injection
   */
  static _buildPlaybookSection(playbook) {
    const pbParts = [];
    pbParts.push(`## PLAYBOOK (v${playbook.version || 1})`);

    if (playbook.openingScript) {
      pbParts.push(`### GUIÃ“N DE APERTURA\n${playbook.openingScript}`);
    }

    if (playbook.qualifyingQuestions?.length > 0) {
      const qs = playbook.qualifyingQuestions
        .map((q, i) => `${i + 1}. ${typeof q === "string" ? q : q.question || JSON.stringify(q)}`)
        .join("\n");
      pbParts.push(`### PREGUNTAS DE CALIFICACIÃ“N\n${qs}`);
    }

    if (playbook.objectionHandlers?.length > 0) {
      const ohs = playbook.objectionHandlers
        .map(oh => {
          if (typeof oh === "string") return `- ${oh}`;
          return `- **ObjeciÃ³n:** ${oh.objection || oh.trigger || ""}\n  **Respuesta:** ${oh.response || oh.handler || ""}`;
        })
        .join("\n");
      pbParts.push(`### MANEJO DE OBJECIONES\n${ohs}`);
    }

    if (playbook.valueProps?.length > 0) {
      const vps = playbook.valueProps
        .map(v => typeof v === "string" ? `- ${v}` : `- ${v.title || ""}: ${v.description || ""}`)
        .join("\n");
      pbParts.push(`### PROPUESTAS DE VALOR\n${vps}`);
    }

    if (playbook.ctaLinks?.length > 0) {
      const ctas = playbook.ctaLinks
        .map(c => typeof c === "string" ? `- ${c}` : `- ${c.label || ""}: ${c.url || ""}`)
        .join("\n");
      pbParts.push(`### LINKS / CTAs\n${ctas}`);
    }

    if (playbook.planRules?.length > 0) {
      const rules = playbook.planRules
        .map(r => typeof r === "string" ? `- ${r}` : `- ${JSON.stringify(r)}`)
        .join("\n");
      pbParts.push(`### REGLAS DE PLAN\n${rules}`);
    }

    return pbParts.join("\n\n");
  }
}

/**
 * VoiceMapper - Map voice names to OpenAI voices
 */
class VoiceMapper {
  static VOICE_MAP = {
    sarah: "shimmer", rachel: "alloy", domi: "coral", bella: "sage",
    antoni: "ash", elli: "shimmer", josh: "echo", arnold: "verse",
    adam: "ballad", sam: "marin", aria: "shimmer"
  };

  static mapToOpenAI(voice) {
    if (!voice) return DEFAULT_VOICE;
    const lower = String(voice).toLowerCase();
    if (VALID_OPENAI_VOICES.includes(lower)) return lower;
    return this.VOICE_MAP[lower] || DEFAULT_VOICE;
  }
}

// ============================================================
// SECTION 7: TOOL EXECUTION
// ============================================================

/**
 * ToolExecutor - Execute tools with deduplication, metrics, logging, and response routing
 * ENHANCED v7: Adds ToolCallLogger.record() and uses dynamic tool schemas
 */
class ToolExecutor {
  static getCustomerPhone(session, args) {
    const phone = args.phone || session.customerPhone ||
      (session.direction === "outbound" ? session.toNumber : session.fromNumber) ||
      session.fromNumber || session.toNumber;
    if (phone && !args.phone) args.phone = phone;
    return Parser.normalizePhone(phone);
  }

  static async execute(session, toolName, callId, args) {
    if (session.callEnding) {
      logger.debug("Tool blocked (call ending)", { toolName, callSid: session.callSid });
      return;
    }

    const startTime = Date.now();
    logger.info("Tool execution started", { callSid: session.callSid, toolName, callId });

    // Check deduplication
    const dedupCheck = ToolDeduplicator.shouldExecute(session, toolName, args);
    if (!dedupCheck.shouldExecute) {
      const result = dedupCheck.previousResult || { success: false, error: "Duplicate call detected" };
      this._sendToolResult(session, callId, result, toolName);
      return result;
    }

    let result;

    try {
      if (toolName === "end_call") {
        result = await this._executeEndCall(session, args);
      } else if (toolName === "transfer_to_human") {
        result = await this._executeTransfer(session, args);
      } else if (toolName === "lookup_contact") {
        result = await this._executeLookup(session, args);
      } else {
        const phone = this.getCustomerPhone(session, args);
        result = await CRMToolsClient.executeTool(toolName, { ...args, phone }, {
          companyId: session.companyId, agentId: session.agentId,
          callSid: session.callSid, customerPhone: phone, direction: session.direction
        });
      }
    } catch (error) {
      result = { success: false, error: error.message };
    }

    const duration = Date.now() - startTime;
    ToolDeduplicator.recordExecution(session, toolName, args, result);

    // NEW v7: Record to persistent tool call log
    ToolCallLogger.record(session, toolName, args, result, duration);

    logger.info("Tool execution completed", { callSid: session.callSid, toolName, durationMs: duration, success: result?.success !== false });

    this._sendToolResult(session, callId, result, toolName);
    return result;
  }

  static _sendToolResult(session, callId, result, toolName) {
    if (session.openaiWs?.readyState === WebSocket.OPEN && !session.callEnding) {
      session.openaiWs.send(JSON.stringify({
        type: "conversation.item.create",
        item: { type: "function_call_output", call_id: callId, output: JSON.stringify(result) }
      }));
      if (!session.callEnding) {
        ResponseLockManager.sendResponseCreateSafe(
          session,
          { type: "response.create", response: { modalities: ["text", "audio"] } },
          "tool_" + toolName
        );
      }
    }
  }

  static async _executeEndCall(session, args) {
    logger.info("End call processing", { callSid: session.callSid });
    const goodbye = args.goodbye_message || args.goodbyeMessage || "Goodbye, have a great day!";

    if (session.openaiWs?.readyState === WebSocket.OPEN) {
      session.openaiWs.send(JSON.stringify({
        type: "conversation.item.create",
        item: {
          type: "message", role: "system",
          content: [{ type: "input_text", text: `[END CALL - MANDATORY GOODBYE] Say exactly: "${goodbye}" â€” Do NOT add anything else.` }]
        }
      }));
      ResponseLockManager.sendResponseCreateSafe(
        session,
        { type: "response.create", response: { modalities: ["text", "audio"] } },
        "end_call"
      );
    }

    session.callEnding = true;
    setTimeout(() => {
      if (session.openaiWs?.readyState === WebSocket.OPEN) session.openaiWs.close(1000, "end_call");
      setTimeout(() => {
        if (session.twilioWs?.readyState === WebSocket.OPEN) session.twilioWs.close(1000, "end_call");
      }, 500);
    }, 3500);

    return { success: true, message: "Call ended" };
  }

  static async _executeTransfer(session, args) {
    if (!session.config?.humanAgents?.length) return { success: false, error: "No human agents available" };
    const name = args.agent_name || args.agentName || args.reason;
    let target = name ? session.config.humanAgents.find(a => a.name.toLowerCase().includes(name.toLowerCase())) : null;
    if (!target) target = session.config.humanAgents[0];
    if (!target) return { success: false, error: "Agent not found" };

    try {
      const profileRes = await SupabaseClient.request("agent_profiles?agent_id=eq." + target.id + "&select=dial_target,phone");
      const dialTarget = profileRes.ok && profileRes.data?.[0] ? (profileRes.data[0].dial_target || profileRes.data[0].phone) : null;
      if (!dialTarget) return { success: false, error: "No phone for " + target.name };
      return { success: true, transfer_to: dialTarget, agent_name: target.name, action: "transfer" };
    } catch (e) {
      return { success: false, error: e.message };
    }
  }

  static async _executeLookup(session, args) {
    if (session.preloadedContact) return { found: true, contact: session.preloadedContact, source: "preloaded" };
    const phone = this.getCustomerPhone(session, args);
    try {
      const res = await SupabaseClient.request("crm_contacts?phone=eq." + encodeURIComponent(phone) + "&select=*");
      if (res.ok && res.data?.[0]) {
        const c = res.data[0];
        session.preloadedContact = {
          id: c.id, name: c.name || c.full_name,
          email: c.email, phone: c.phone,
          language: c.language || DEFAULT_LANGUAGE
        };
        return { found: true, contact: session.preloadedContact };
      }
      return { found: false, message: "Contact not found" };
    } catch (e) {
      return { found: false, error: e.message };
    }
  }

  /**
   * Build tool definitions for OpenAI session.update
   * ENHANCED v7: Uses dynamic tools from bc_agent_tools if loaded, otherwise hardcoded defaults
   */
  static buildToolDefinitions(session, config) {
    // NEW v7: If dynamic tools were loaded from DB, convert them to OpenAI format
    if (session.dynamicTools?.length > 0) {
      const tools = session.dynamicTools
        .filter(t => t.schema)
        .map(t => {
          // If schema is already in OpenAI format, use directly
          if (t.schema.type === "function" && t.schema.function) {
            return t.schema;
          }
          // Wrap in OpenAI format
          return {
            type: "function",
            name: t.name,
            description: t.schema.description || t.name,
            parameters: t.schema.parameters || t.schema
          };
        });

      // Always ensure end_call and transfer_to_human are available
      const hasEndCall = tools.some(t => (t.name || t.function?.name) === "end_call");
      const hasTransfer = tools.some(t => (t.name || t.function?.name) === "transfer_to_human");

      if (!hasEndCall) {
        tools.push({ type: "function", name: "end_call", description: "End the call politely.", parameters: { type: "object", properties: { reason: { type: "string" }, outcome: { type: "string" }, goodbye_message: { type: "string" } } } });
      }
      if (!hasTransfer) {
        tools.push({ type: "function", name: "transfer_to_human", description: "Transfer call to a human agent.", parameters: { type: "object", properties: { agent_name: { type: "string" }, reason: { type: "string" } }, required: ["reason"] } });
      }

      logger.info("Using dynamic tools from DB", { count: tools.length });
      return tools;
    }

    // Fallback: hardcoded tool definitions (original v6.2.0 behavior)
    const tools = [];
    const hasContact = session.preloadedContact?.name;
    const isDemoCall = session.isDemoCall === true;

    if (!hasContact) {
      tools.push({ type: "function", name: "lookup_contact", description: "Look up contact by phone number.", parameters: { type: "object", properties: { phone: { type: "string", description: "Phone number to search" }, email: { type: "string", description: "Email to search" } } } });
    }

    tools.push({ type: "function", name: "create_or_merge_contact", description: "Create new contact or update existing.", parameters: { type: "object", properties: { phone: { type: "string" }, name: { type: "string" }, email: { type: "string" } }, required: ["phone", "name"] } });
    tools.push({ type: "function", name: "create_lead", description: "Create a lead for opportunity tracking.", parameters: { type: "object", properties: { contact_id: { type: "string" }, phone: { type: "string" }, title: { type: "string" }, notes: { type: "string" }, temperature: { type: "string", enum: ["hot", "warm", "cold"] } }, required: ["title"] } });

    if (!isDemoCall) {
      tools.push({ type: "function", name: "schedule_appointment", description: "Schedule an appointment.", parameters: { type: "object", properties: { phone: { type: "string" }, name: { type: "string" }, start_at: { type: "string", description: "ISO datetime" }, title: { type: "string" }, notes: { type: "string" } }, required: ["start_at"] } });
    }

    tools.push({ type: "function", name: "check_appointments", description: "Check upcoming appointments.", parameters: { type: "object", properties: { phone: { type: "string" } }, required: ["phone"] } });
    tools.push({ type: "function", name: "take_note", description: "Save a note about the call.", parameters: { type: "object", properties: { note: { type: "string" } }, required: ["note"] } });
    tools.push({ type: "function", name: "send_message", description: "Send an SMS to the customer.", parameters: { type: "object", properties: { phone: { type: "string" }, message: { type: "string" } }, required: ["message"] } });
    tools.push({ type: "function", name: "send_email", description: "Send an email.", parameters: { type: "object", properties: { email: { type: "string" }, subject: { type: "string" }, body: { type: "string" } }, required: ["subject", "body"] } });
    tools.push({ type: "function", name: "transfer_to_human", description: "Transfer call to a human agent.", parameters: { type: "object", properties: { agent_name: { type: "string" }, reason: { type: "string" } }, required: ["reason"] } });
    tools.push({ type: "function", name: "end_call", description: "End the call politely.", parameters: { type: "object", properties: { reason: { type: "string" }, outcome: { type: "string" }, goodbye_message: { type: "string" } } } });

    return tools;
  }
}

// ============================================================
// SECTION 8: HANDLERS
// ============================================================

/**
 * OpenAIHandler - Handle OpenAI Realtime API connections and messages
 * ENHANCED v7: Uses dynamic AI model, temperature, max_tokens, STT config
 */
class OpenAIHandler {
  static async connect(session) {
    const startTime = Date.now();

    try {
      // NEW v7: Use dynamic AI model from config if available
      const model = session.config?.aiModel || OPENAI_REALTIME_MODEL;

      const ws = await openaiCircuit.execute(async () => {
        return new Promise((resolve, reject) => {
          const wsUrl = `wss://api.openai.com/v1/realtime?model=${model}`;
          const openaiWs = new WebSocket(wsUrl, {
            headers: {
              "Authorization": `Bearer ${OPENAI_API_KEY}`,
              "OpenAI-Beta": "realtime=v1"
            }
          });

          const timeout = setTimeout(() => {
            openaiWs.close();
            reject(new Error("OpenAI connection timeout"));
          }, 10000);

          openaiWs.on("open", () => { clearTimeout(timeout); resolve(openaiWs); });
          openaiWs.on("error", (error) => { clearTimeout(timeout); reject(error); });
        });
      });

      session.openaiWs = ws;
      session.metrics.t_openai_connected = Date.now();
      logger.info("OpenAI connected", {
        callSid: session.callSid || "prewarm",
        model,
        durationMs: Date.now() - startTime
      });
      this.setupMessageHandler(session);
      return ws;
    } catch (error) {
      logger.error("OpenAI connection failed", { callSid: session.callSid, error: error.message });
      throw error;
    }
  }

  static setupMessageHandler(session) {
    const ws = session.openaiWs;
    ResponseLockManager.init(session);

    ws.on("message", async (data) => {
      const event = Parser.safeJsonParse(data.toString(), null);
      if (!event) return;

      switch (event.type) {
        case "session.created":
          session.sessionCreated = true;
          logger.info("OpenAI session created", { callSid: session.callSid || "prewarm" });
          if (session.config && session.configReady) {
            this.sendSessionUpdate(session);
          }
          break;

        case "session.updated":
          session.sessionReady = true;
          session.pendingSessionUpdate = false;
          if (session.metrics) session.metrics.t_session_ready = Date.now();
          logger.info("OpenAI session updated", { callSid: session.callSid || "prewarm" });
          TwilioHandler.tryTriggerGreetingWhenReady(session);
          break;

        case "response.audio.delta":
          if (session.twilioWs?.readyState === WebSocket.OPEN && session.streamSid) {
            if (!session.firstAudioSent) {
              session.firstAudioSent = true;
              session.metrics.t_first_audio_sent = Date.now();
              TwilioHandler.stopRingback(session);
              logger.info("First audio sent", {
                callSid: session.callSid,
                latencyMs: session.metrics.t_first_audio_sent - (session.metrics.t_stream_start || session.metrics.t_session_created)
              });
            }
            session.twilioWs.send(JSON.stringify({
              event: "media", streamSid: session.streamSid,
              media: { payload: event.delta }
            }));
          }
          break;

        case "response.audio_transcript.done":
          if (event.transcript) {
            session.transcripts.assistant.push(event.transcript);
            logger.debug("Assistant transcript", { callSid: session.callSid, transcript: event.transcript.substring(0, 100) });
            if (!session.callEnding) {
              AutoHangupManager.checkForGoodbye(session, event.transcript);
            }
          }
          break;

        case "conversation.item.input_audio_transcription.completed":
          if (event.transcript) {
            session.transcripts.user.push(event.transcript);
            logger.debug("User transcript", { callSid: session.callSid, transcript: event.transcript.substring(0, 100) });
            AutoHangupManager.cancelHangup(session);

            // Language detection
            const detectedLang = LanguageDetector.detect(event.transcript);
            if (detectedLang && detectedLang !== session.language) {
              await LanguageDetector.updateSessionLanguage(session, detectedLang);
            }

            // Voicemail detection
            if (!session.voicemailHandled && VoicemailDetector.detect(event.transcript)) {
              await VoicemailDetector.handleDetection(session);
            }
          }
          break;

        case "response.done":
          ResponseLockManager.unlock(session, "response.done");
          break;

        case "response.function_call_arguments.done":
          await ToolExecutor.execute(session, event.name, event.call_id, Parser.safeJsonParse(event.arguments, {}));
          break;

        case "error":
          logger.error("OpenAI error", { callSid: session.callSid, error: JSON.stringify(event.error) });
          break;
      }
    });

    ws.on("close", (code, reason) => {
      logger.info("OpenAI connection closed", { callSid: session.callSid || "prewarm", code });
      if (session.callSid) {
        this.syncTranscripts(session);
        // NEW v7: Persist tool call logs on close
        ToolCallLogger.persist(session).catch(e =>
          logger.error("Tool log persist on close failed", { error: e.message })
        );
      }
    });

    ws.on("error", (error) => {
      logger.error("OpenAI WebSocket error", { callSid: session.callSid, error: error.message });
    });
  }

  /**
   * ENHANCED v7: sendSessionUpdate now uses dynamic temperature, max_tokens, STT config
   */
  static sendSessionUpdate(session) {
    if (!session.openaiWs || session.openaiWs.readyState !== WebSocket.OPEN) return;

    const config = session.config;
    const prompt = PromptBuilder.build(session, config);
    const voice = VoiceMapper.mapToOpenAI(config.voice);
    const tools = ToolExecutor.buildToolDefinitions(session, config);

    const promptSource = session.dynamicInstructions
      ? (session.dynamicInstructionsMode === "full" ? "dynamic_full" : "merged")
      : "default";

    logger.info("Sending session.update", {
      callSid: session.callSid || "prewarm",
      promptSource, promptLength: prompt.length,
      voice, toolCount: tools.length,
      aiModel: config.aiModel,
      temperature: config.aiTemperature,
      sttModel: config.sttModel
    });

    if (session.callSid) session.pendingSessionUpdate = true;

    const sessionConfig = {
      modalities: ["text", "audio"],
      voice,
      instructions: prompt,
      input_audio_format: "g711_ulaw",
      output_audio_format: "g711_ulaw",
      input_audio_transcription: {
        model: config.sttModel || "whisper-1",
        language: config.sttLanguage || config.language || DEFAULT_LANGUAGE  // NEW v7
      },
      turn_detection: {
        type: "server_vad",
        threshold: 0.5,
        prefix_padding_ms: 300,
        silence_duration_ms: 500
      },
      tools,
      // NEW v7: Dynamic temperature and max_tokens
      temperature: config.aiTemperature ?? 0.8,
      max_response_output_tokens: config.aiMaxTokens ?? 4096
    };

    session.openaiWs.send(JSON.stringify({
      type: "session.update",
      session: sessionConfig
    }));
  }

  static async syncTranscripts(session) {
    if (!session.callSid) return;
    const userTranscripts = session.transcripts?.user || [];
    const assistantTranscripts = session.transcripts?.assistant || [];
    if (userTranscripts.length === 0 && assistantTranscripts.length === 0) return;

    logger.info("Syncing transcripts", {
      callSid: session.callSid,
      userCount: userTranscripts.length,
      assistantCount: assistantTranscripts.length
    });

    try {
      await fetch(SYNC_TRANSCRIPT_URL, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${SUPABASE_SERVICE_KEY}`
        },
        body: JSON.stringify({
          call_sid: session.callSid,
          agent_id: session.agentId,
          company_id: session.companyId,
          user_transcripts: userTranscripts,
          assistant_transcripts: assistantTranscripts,
          direction: session.direction,
          from_number: session.fromNumber,
          to_number: session.toNumber
        })
      });
    } catch (error) {
      logger.error("Transcript sync failed", { callSid: session.callSid, error: error.message });
    }
  }
}

/**
 * TwilioHandler - Handle Twilio Media Streams with full param support
 * ENHANCED v7: Loads dynamic tools and playbook on call start
 */
class TwilioHandler {
  static async handleConnection(twilioWs, request) {
    const startTime = Date.now();
    const sessionId = generateSessionId();

    logger.info("Twilio WebSocket connected", { sessionId });

    // Parse URL params
    const urlParams = {};
    if (request.url?.includes("?")) {
      const qs = request.url.split("?")[1];
      for (const pair of qs.split("&")) {
        const [k, v] = pair.split("=");
        urlParams[k.toLowerCase()] = decodeURIComponent(v || "");
      }
    }

    // Create session with initial URL params
    const session = SessionManager.createSession({
      sessionId,
      agentId: urlParams.agentid || urlParams.agent_id || null,
      companyId: urlParams.companyid || urlParams.company_id || null,
      direction: urlParams.direction || "inbound",
      fromNumber: urlParams.from || urlParams.fromnumber || null,
      toNumber: urlParams.to || urlParams.tonumber || null
    });

    session.twilioWs = twilioWs;

    twilioWs.on("message", async (data) => {
      const message = Parser.safeJsonParse(data.toString(), null);
      if (!message) return;

      try {
        switch (message.event) {
          case "connected":
            logger.debug("Twilio stream connected", { sessionId });
            break;

          case "start":
            await this._handleStart(session, message, urlParams);
            break;

          case "media":
            if (!session.twilioStreamReady) {
              session.twilioStreamReady = true;
              logger.debug("First media received â€” twilioStreamReady", { callSid: session.callSid });
              this.tryTriggerGreetingWhenReady(session);
            }
            if (session.openaiWs?.readyState === WebSocket.OPEN) {
              session.openaiWs.send(JSON.stringify({
                type: "input_audio_buffer.append",
                audio: message.media.payload
              }));
            }
            break;

          case "stop":
            await this._handleStop(session);
            break;
        }
      } catch (error) {
        logger.error("Twilio message handler error", { sessionId, event: message.event, error: error.message });
      }
    });

    twilioWs.on("close", () => {
      logger.info("Twilio WebSocket closed", { sessionId, callSid: session.callSid });
      SessionManager.deleteSession(sessionId);
    });

    twilioWs.on("error", (error) => {
      logger.error("Twilio WebSocket error", { sessionId, error: error.message });
    });
  }

  static async _handleStart(session, message, urlParams) {
    session.streamSid = message.streamSid;
    session.callSid = message.start.callSid;
    const params = message.start.customParameters || {};

    // Extract phones
    const extractedFrom = params.From || params.from || params.caller || message.start.from || urlParams.from || session.fromNumber;
    const extractedTo = params.To || params.to || params.called || message.start.to || urlParams.to || session.toNumber;
    if (extractedFrom) session.fromNumber = extractedFrom;
    if (extractedTo) session.toNumber = extractedTo;

    const direction = params.direction || session.direction || "inbound";
    session.direction = direction;
    session.customerPhone = direction === "outbound" ? session.toNumber : session.fromNumber;

    session.agentId = params.agentId || params.agent_id || params.agentid || session.agentId;
    session.companyId = params.companyId || params.company_id || params.companyid || session.companyId;

    logger.info("Stream start", {
      callSid: session.callSid, direction: session.direction,
      from: session.fromNumber, to: session.toNumber,
      agentId: session.agentId, companyId: session.companyId
    });

    // Validate
    if (!Validator.isValidUUID(session.agentId) || !Validator.isValidUUID(session.companyId)) {
      logger.error("Invalid agent/company ID", { agentId: session.agentId, companyId: session.companyId });
      session.twilioWs.close(1008, "Invalid parameters");
      return;
    }

    // Rate limit check
    const tenantLimit = RateLimiter.checkTenantLimit(session.companyId);
    if (!tenantLimit.allowed) {
      logger.warn("Rate limit exceeded", { companyId: session.companyId, reason: tenantLimit.reason });
      session.twilioWs.close(1008, tenantLimit.reason);
      return;
    }
    RateLimiter.incrementTenantCalls(session.companyId);

    // Spam check (inbound only)
    if (direction === "inbound") {
      const spamCheck = SpamFilter.shouldBlockCall(session.fromNumber);
      if (spamCheck.blocked) {
        logger.warn("Spam call blocked", { callSid: session.callSid, fromNumber: session.fromNumber });
        RateLimiter.decrementTenantCalls(session.companyId);
        session.twilioWs.close(1000, "spam_blocked");
        return;
      }
    }

    // ==================== DECODE TwiML URL PARAMETERS ====================
    const dynB64 = params.dynB64 || params.dynamicInstructions;
    const fmB64 = params.fmB64 || params.firstMessage;
    const skipGreeting = params.skipGreeting === "true" || params.skip_greeting === "true";
    const prepId = params.prepId || params.prep_id || params.prepid;
    const preloadedContact = params.preloadedContact || params.contact_name || params.contactName;
    const urlDynMode = params.dynamicInstructionsMode || params.dynamic_instructions_mode || null;
    const forceNewSession = params.forceNewSession === "true" || params.force_new_session === "true";
    const skipPrewarm = params.skipPrewarm === "true" || params.skip_prewarm === "true";

    logger.info("TwiML params", { dynB64: !!dynB64, fmB64: !!fmB64, prepId, forceNew: forceNewSession, skipPrewarm });

    if (dynB64) {
      const decoded = Parser.decodeBase64Utf8(dynB64);
      if (decoded) { session.dynamicInstructions = decoded; session.dynamicInstructionsMode = urlDynMode || "full"; }
    }

    if (fmB64) {
      const decoded = Parser.decodeBase64Utf8(fmB64);
      if (decoded) session.dynamicFirstMessage = decoded;
    }

    if (preloadedContact) {
      session.preloadedContact = session.preloadedContact || {};
      session.preloadedContact.name = preloadedContact;
      session.preloadedContact.safeName = BusinessNameDetector.getSafeContactName(preloadedContact);
    }

    session.skipGreeting = skipGreeting;

    // ==================== PREWARM REUSE ====================
    let prewarmSession = prepId ? prewarmSessions.get(prepId) : null;

    if (prewarmSession && (forceNewSession || skipPrewarm)) {
      logger.info("Force destroy prewarm", { forceNew: forceNewSession, skipPrewarm });
      if (prewarmSession.openaiWs?.readyState === WebSocket.OPEN) prewarmSession.openaiWs.close(1000, "force_new_session");
      prewarmSessions.delete(prepId);
      prewarmSession = null;
    }

    if (prewarmSession && prewarmSession.sessionReady) {
      logger.info("Reusing prewarm", { prepId, ageMs: Date.now() - prewarmSession.createdAt });

      session.openaiWs = prewarmSession.openaiWs;
      session.config = prewarmSession.config;
      session.configReady = true;
      session.sessionCreated = prewarmSession.sessionCreated;
      session.sessionReady = prewarmSession.sessionReady;

      // CRITICAL: Prewarm override check
      let needsSessionRefresh = false;
      const effectiveMode = session.dynamicInstructionsMode || prewarmSession.dynamicInstructionsMode || "addon";

      if (session.dynamicInstructions && (effectiveMode === "full" || effectiveMode === "replace")) {
        logger.info("Prewarm override: replacing prompt", { mode: effectiveMode });
        session.dynamicInstructionsMode = "full";
        needsSessionRefresh = true;
      } else {
        session.dynamicInstructions = session.dynamicInstructions || prewarmSession.dynamicInstructions;
        session.dynamicInstructionsMode = effectiveMode;
      }

      session.dynamicFirstMessage = session.dynamicFirstMessage || prewarmSession.firstMessage || prewarmSession.prepFirstMessage;
      session.preloadedContact = session.preloadedContact || prewarmSession.preloadedContact;
      session.isDemoCall = prewarmSession.isDemoCall;
      session.language = session.language || prewarmSession.language;
      session.greetingMessageSent = false;

      prewarmSessions.delete(prepId);

      // Re-bind OpenAI handler to this session
      OpenAIHandler.setupMessageHandler(session);

      if (needsSessionRefresh) {
        logger.info("Sending session.update with NEW instructions (prewarm override)");
        OpenAIHandler.sendSessionUpdate(session);
      }
    } else {
      // ==================== COLD START ====================
      logger.info("Cold start â€” no prewarm", { callSid: session.callSid });
      if (prepId) {
        session.prepId = prepId;
        await SupabaseClient.loadPrepSession(prepId, session);
      }
      const config = await SupabaseClient.loadAgentConfig(session.agentId, session.companyId);
      session.config = config;
      session.configReady = true;
    }

    // NEW v7: Load dynamic tools and playbook
    const dynamicTools = await DynamicToolLoader.loadTools(session.agentId);
    if (dynamicTools) {
      session.dynamicTools = dynamicTools;
    }

    const playbook = await PlaybookLoader.loadPlaybook(
      session.agentId,
      session.language || session.config?.language || DEFAULT_LANGUAGE
    );
    if (playbook) {
      session.playbook = playbook;
    }

    // Register session by callSid and create call record
    sessions.set(session.callSid, session);
    this._createCallRecord(session);
    this.startRingback(session);
    session.metrics.t_stream_start = Date.now();

    if (!session.openaiWs || session.openaiWs.readyState !== WebSocket.OPEN) {
      await OpenAIHandler.connect(session);
    } else {
      // If prewarm was reused but we loaded new tools/playbook, send session.update
      if ((session.dynamicTools || session.playbook) && !session.pendingSessionUpdate) {
        OpenAIHandler.sendSessionUpdate(session);
      }
      this.tryTriggerGreetingWhenReady(session);
    }
  }

  static async _handleStop(session) {
    logger.info("Twilio stream stopped", { callSid: session.callSid });
    session.metrics.t_call_ended = Date.now();

    if (session.openaiWs?.readyState === WebSocket.OPEN) {
      session.openaiWs.close(1000, "stream_stopped");
    }

    // Send webhook if configured
    if (session.config?.webhook_url) {
      await WebhookClient.send(session.config.webhook_url, {
        event: "call_ended",
        call_sid: session.callSid,
        duration_ms: session.metrics.t_call_ended - session.metrics.t_session_created,
        transcripts: session.transcripts
      });
    }
  }

  // ==================== GREETING SYSTEM ====================

  static tryTriggerGreetingWhenReady(session) {
    if (session.greetingTriggered || session.callEnding) return;
    if (!session.twilioStreamReady || !session.sessionCreated || session.pendingSessionUpdate || !session.sessionReady) return;
    this._triggerGreeting(session);
  }

  static _triggerGreeting(session) {
    if (session.greetingTriggered) return;
    session.greetingTriggered = true;
    this.stopRingback(session);

    const safeName = session.preloadedContact ? BusinessNameDetector.getSafeContactName(session.preloadedContact.name) : null;
    const isOutbound = session.direction === "outbound";

    if (isOutbound) {
      let greeting = session.dynamicFirstMessage || session.config?.firstMessage;

      // Generate generic greeting if contact name is a business name
      if (greeting && session.preloadedContact && !safeName) {
        const agentName = session.config?.companyName ? "" : "un representante";
        const company = session.config?.companyName || "";
        greeting = session.language === "en"
          ? `Hello! This is ${agentName || "a representative"}${company ? " from " + company : ""}. Do you have a moment to talk?`
          : `Â¡Hola! Soy ${agentName || "un representante"}${company ? " de " + company : ""}. Â¿Tiene un momento para hablar?`;
      }

      if (greeting) {
        logger.info("Outbound greeting", { callSid: session.callSid, greeting: greeting.substring(0, 80) });

        // NEW v7: Use ElevenLabs TTS for greeting if configured
        if (session.config?.voiceProvider === "elevenlabs" && ELEVENLABS_API_KEY) {
          this._sendElevenLabsGreeting(session, greeting);
        } else {
          session.openaiWs.send(JSON.stringify({
            type: "conversation.item.create",
            item: { type: "message", role: "user", content: [{ type: "input_text", text: "[CALL CONNECTED - Customer answered. Deliver your opening greeting NOW.]" }] }
          }));
          ResponseLockManager.sendResponseCreateSafe(session, {
            type: "response.create",
            response: { modalities: ["text", "audio"], instructions: `Say exactly: "${greeting}"` }
          }, "outbound_greeting");
        }
      } else {
        session.openaiWs.send(JSON.stringify({
          type: "conversation.item.create",
          item: { type: "message", role: "user", content: [{ type: "input_text", text: "[CALL CONNECTED - Customer answered. Deliver your opening greeting NOW.]" }] }
        }));
        ResponseLockManager.sendResponseCreateSafe(session, {
          type: "response.create", response: { modalities: ["text", "audio"] }
        }, "outbound_generic");
      }
    } else {
      // Inbound
      let greeting = session.dynamicFirstMessage || session.config?.firstMessage;

      if (greeting && session.preloadedContact && !safeName) {
        const company = session.config?.companyName || "";
        greeting = session.language === "en"
          ? `Hello! Thank you for calling${company ? " " + company : ""}. How can I help you today?`
          : `Â¡Hola! Gracias por llamar${company ? " a " + company : ""}. Â¿En quÃ© puedo ayudarle hoy?`;
      }

      if (greeting) {
        logger.info("Inbound greeting", { callSid: session.callSid, greeting: greeting.substring(0, 80) });

        // NEW v7: Use ElevenLabs TTS for greeting if configured
        if (session.config?.voiceProvider === "elevenlabs" && ELEVENLABS_API_KEY) {
          this._sendElevenLabsGreeting(session, greeting);
        } else {
          session.openaiWs.send(JSON.stringify({
            type: "conversation.item.create",
            item: { type: "message", role: "user", content: [{ type: "input_text", text: "[CALL STARTED - Customer is calling in. Greet them immediately.]" }] }
          }));
          ResponseLockManager.sendResponseCreateSafe(session, {
            type: "response.create",
            response: { modalities: ["text", "audio"], instructions: `Say exactly: "${greeting}"` }
          }, "inbound_greeting");
        }
      } else {
        session.openaiWs.send(JSON.stringify({
          type: "conversation.item.create",
          item: { type: "message", role: "user", content: [{ type: "input_text", text: "[CALL STARTED - Customer is calling in. Greet them now.]" }] }
        }));
        ResponseLockManager.sendResponseCreateSafe(session, {
          type: "response.create", response: { modalities: ["text", "audio"] }
        }, "inbound_generic");
      }
    }
  }

  /**
   * NEW v7: Send greeting via ElevenLabs TTS instead of OpenAI
   */
  static async _sendElevenLabsGreeting(session, greeting) {
    try {
      const config = session.config;
      const audioBuffer = await ElevenLabsTTSClient.synthesize(greeting, {
        voiceId: config.elevenlabsVoiceId,
        stability: config.elevenlabsStability,
        similarityBoost: config.elevenlabsSimilarityBoost,
        style: config.elevenlabsStyle,
        speed: config.elevenlabsSpeed,
        modelId: config.elevenlabsModelId
      });

      // Send audio to Twilio (already in ulaw_8000 format)
      if (session.twilioWs?.readyState === WebSocket.OPEN && session.streamSid) {
        const base64Audio = audioBuffer.toString("base64");
        session.twilioWs.send(JSON.stringify({
          event: "media",
          streamSid: session.streamSid,
          media: { payload: base64Audio }
        }));
        session.firstAudioSent = true;
        logger.info("ElevenLabs greeting sent", { callSid: session.callSid });
      }

      // Also inform OpenAI that greeting was delivered (so it doesn't repeat)
      if (session.openaiWs?.readyState === WebSocket.OPEN) {
        session.openaiWs.send(JSON.stringify({
          type: "conversation.item.create",
          item: {
            type: "message", role: "assistant",
            content: [{ type: "input_text", text: greeting }]
          }
        }));
      }
    } catch (error) {
      logger.error("ElevenLabs greeting failed, falling back to OpenAI", {
        callSid: session.callSid, error: error.message
      });
      // Fallback to OpenAI
      session.openaiWs.send(JSON.stringify({
        type: "conversation.item.create",
        item: { type: "message", role: "user", content: [{ type: "input_text", text: "[Deliver your opening greeting NOW.]" }] }
      }));
      ResponseLockManager.sendResponseCreateSafe(session, {
        type: "response.create",
        response: { modalities: ["text", "audio"], instructions: `Say exactly: "${greeting}"` }
      }, "elevenlabs_fallback_greeting");
    }
  }

  // ==================== RINGBACK ====================

  static startRingback(session) {
    if (session.ringbackInterval) return;
    session.ringbackFrames = 0;
    session.ringbackInterval = setInterval(() => {
      if (session.twilioWs?.readyState === WebSocket.OPEN && session.streamSid) {
        session.twilioWs.send(JSON.stringify({
          event: "media", streamSid: session.streamSid,
          media: { payload: RINGBACK_SILENCE_FRAME }
        }));
        session.ringbackFrames++;
      }
    }, RINGBACK_INTERVAL_MS);

    // Safety: stop after 10 seconds
    setTimeout(() => this.stopRingback(session), 10000);
  }

  static stopRingback(session) {
    if (!session.ringbackInterval) return;
    clearInterval(session.ringbackInterval);
    session.ringbackInterval = null;
    logger.debug("Ringback stopped", { callSid: session.callSid, frames: session.ringbackFrames });
    if (session.twilioWs?.readyState === WebSocket.OPEN && session.streamSid) {
      session.twilioWs.send(JSON.stringify({ event: "clear", streamSid: session.streamSid }));
    }
  }

  // ==================== CALL RECORD ====================

  static async _createCallRecord(session) {
    try {
      const res = await fetch(UPSERT_CALL_RECORD_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json", "Authorization": `Bearer ${SUPABASE_SERVICE_KEY}` },
        body: JSON.stringify({
          twilio_call_sid: session.callSid,
          agent_id: session.agentId,
          company_id: session.companyId,
          from_number: session.fromNumber,
          to_number: session.toNumber,
          direction: session.direction,
          status: "in-progress"
        })
      });
      const result = Parser.safeJsonParse(await res.text(), null);
      if (res.ok && result?.success) {
        session.callDbId = result.id;
        logger.info("Call record upserted", { callSid: session.callSid, id: result.id });
      }
    } catch (e) {
      logger.error("Call record error", { callSid: session.callSid, error: e.message });
    }
  }
}

// ============================================================
// SECTION 9: OBSERVABILITY
// ============================================================

/**
 * MetricsCollector - Collect and expose metrics
 */
class MetricsCollector {
  static getMetrics() {
    if (!ENABLE_METRICS) return { enabled: false };

    const tenantStats = [];
    for (const [companyId, counts] of tenantCallCounts.entries()) {
      tenantStats.push({ companyId, concurrent: counts.concurrent, hourly: counts.hourly.length });
    }

    return {
      version: VERSION,
      timestamp: new Date().toISOString(),
      uptime_seconds: Math.floor(process.uptime()),
      sessions: { active: SessionManager.getActiveSessionCount(), prewarm: SessionManager.getPrewarmSessionCount() },
      circuits: [
        supabaseCircuit.getState(),
        openaiCircuit.getState(),
        crmToolsCircuit.getState(),
        elevenLabsCircuit.getState()  // NEW v7
      ],
      tenants: tenantStats.slice(0, 10),
      memory: {
        used_mb: Math.round(process.memoryUsage().heapUsed / 1024 / 1024),
        total_mb: Math.round(process.memoryUsage().heapTotal / 1024 / 1024)
      }
    };
  }
}

/**
 * HealthCheck - Service health checks
 */
class HealthCheck {
  static async check() {
    const checks = { version: VERSION, timestamp: new Date().toISOString(), status: "healthy", services: {} };

    try {
      const res = await SupabaseClient.request("agents_new?limit=1", "GET");
      checks.services.supabase = { status: res.ok ? "healthy" : "unhealthy", circuit: supabaseCircuit.getState().state };
    } catch (error) {
      checks.services.supabase = { status: "unhealthy", error: error.message, circuit: supabaseCircuit.getState().state };
      checks.status = "degraded";
    }

    checks.services.openai = {
      status: openaiCircuit.getState().state === "OPEN" ? "unhealthy" : "healthy",
      circuit: openaiCircuit.getState().state
    };
    checks.services.crm_tools = {
      status: crmToolsCircuit.getState().state === "OPEN" ? "unhealthy" : "healthy",
      circuit: crmToolsCircuit.getState().state
    };
    // NEW v7
    checks.services.elevenlabs = {
      status: !ELEVENLABS_API_KEY ? "not_configured" : (elevenLabsCircuit.getState().state === "OPEN" ? "unhealthy" : "healthy"),
      circuit: elevenLabsCircuit.getState().state
    };

    const unhealthyServices = Object.values(checks.services).filter(s => s.status === "unhealthy");
    if (unhealthyServices.length > 0) {
      checks.status = unhealthyServices.length === Object.keys(checks.services).length ? "unhealthy" : "degraded";
    }

    return checks;
  }
}

// ============================================================
// SECTION 10: SERVER
// ============================================================

/**
 * HTTP Server with WebSocket support
 */
const server = http.createServer(async (req, res) => {
  const url = new URL(req.url, `http://${req.headers.host}`);
  const path = url.pathname;

  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
  res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");

  if (req.method === "OPTIONS") { res.writeHead(200); res.end(); return; }

  // Rate limiting by IP
  const clientIp = req.headers["x-forwarded-for"] || req.socket.remoteAddress;
  const ipLimit = RateLimiter.checkIPLimit(clientIp);
  if (!ipLimit.allowed) {
    res.writeHead(429, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ error: "Rate limit exceeded", limit: ipLimit.limit }));
    return;
  }

  try {
    // GET / â€” Basic info
    if (path === "/" && req.method === "GET") {
      res.writeHead(200, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ service: "Voice Gateway", version: VERSION, status: "running" }));
      return;
    }

    // GET /health
    if (path === "/health" && req.method === "GET") {
      const health = await HealthCheck.check();
      const statusCode = health.status === "unhealthy" ? 503 : 200;
      res.writeHead(statusCode, { "Content-Type": "application/json" });
      res.end(JSON.stringify({
        ...health,
        activeSessions: SessionManager.getActiveSessionCount(),
        prewarmSessions: SessionManager.getPrewarmSessionCount(),
        // NEW v7: Feature flags
        features: {
          dynamicTools: true,
          elevenLabsTTS: !!ELEVENLABS_API_KEY,
          playbooks: true,
          toolCallLogging: true,
          configurableSTT: true,
          configurableAIModel: true,
          dynamicTemperature: true
        }
      }));
      return;
    }

    // GET /metrics
    if (path === "/metrics" && req.method === "GET") {
      res.writeHead(200, { "Content-Type": "application/json" });
      res.end(JSON.stringify(MetricsCollector.getMetrics()));
      return;
    }

    // GET /sessions (protected)
    if (path === "/sessions" && req.method === "GET") {
      if (VOICE_GATEWAY_TOKEN && req.headers.authorization !== `Bearer ${VOICE_GATEWAY_TOKEN}`) {
        res.writeHead(401, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ error: "Unauthorized" }));
        return;
      }
      const sessionList = [];
      for (const [sessionId, session] of sessions.entries()) {
        sessionList.push({
          session_id: sessionId, call_sid: session.callSid,
          company_id: session.companyId, agent_id: session.agentId,
          direction: session.direction, language: session.language,
          created_at: new Date(session.createdAt).toISOString(),
          duration_ms: Date.now() - session.createdAt
        });
      }
      res.writeHead(200, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ count: sessionList.length, sessions: sessionList }));
      return;
    }

    // NEW v7: POST /cache/invalidate
    if (path === "/cache/invalidate" && req.method === "POST") {
      let body = "";
      req.on("data", chunk => body += chunk);
      req.on("end", () => {
        try {
          if (VOICE_GATEWAY_TOKEN && req.headers.authorization !== `Bearer ${VOICE_GATEWAY_TOKEN}`) {
            res.writeHead(401, { "Content-Type": "application/json" });
            res.end(JSON.stringify({ error: "Unauthorized" }));
            return;
          }
          const data = JSON.parse(body);
          const agentId = data.agent_id || data.agentId;
          DynamicToolLoader.invalidateCache(agentId);
          PlaybookLoader.invalidateCache(agentId);
          if (agentId) agentConfigCache.delete(agentId + "_");
          logger.info("Cache invalidated", { agentId: agentId || "all" });
          res.writeHead(200, { "Content-Type": "application/json" });
          res.end(JSON.stringify({ ok: true, invalidated: agentId || "all" }));
        } catch {
          res.writeHead(400, { "Content-Type": "application/json" });
          res.end(JSON.stringify({ error: "Invalid JSON" }));
        }
      });
      return;
    }

    // POST /prewarm (protected)
    if (path === "/prewarm" && req.method === "POST") {
      let body = "";
      req.on("data", chunk => body += chunk);
      req.on("end", async () => {
        try {
          if (VOICE_GATEWAY_TOKEN && req.headers.authorization !== `Bearer ${VOICE_GATEWAY_TOKEN}`) {
            res.writeHead(401, { "Content-Type": "application/json" });
            res.end(JSON.stringify({ error: "Unauthorized" }));
            return;
          }

          const data = JSON.parse(body);
          const prewarmStart = Date.now();

          if (!Validator.isValidUUID(data.agent_id) || !Validator.isValidUUID(data.company_id)) {
            res.writeHead(400, { "Content-Type": "application/json" });
            res.end(JSON.stringify({ error: "Invalid agent_id or company_id" }));
            return;
          }

          const config = await SupabaseClient.loadAgentConfig(data.agent_id, data.company_id);
          const prepId = data.prep_id || generatePrepId();

          // NEW v7: Pre-load dynamic tools and playbook during prewarm
          const dynamicTools = await DynamicToolLoader.loadTools(data.agent_id);
          const playbook = await PlaybookLoader.loadPlaybook(
            data.agent_id,
            data.language || data.contact_language || DEFAULT_LANGUAGE
          );

          // Create a temporary session for prewarm
          const session = {
            sessionId: prepId,
            prepId,
            agentId: data.agent_id,
            companyId: data.company_id,
            config,
            configReady: true,
            direction: data.direction || "outbound",
            fromNumber: data.from_number || data.from || "",
            toNumber: data.to_number || data.to || "",
            customerPhone: (data.direction || "outbound") === "outbound" ? (data.to_number || data.to || "") : (data.from_number || data.from || ""),
            language: data.language || data.contact_language || DEFAULT_LANGUAGE,
            dynamicInstructions: data.dynamic_instructions || null,
            dynamicInstructionsMode: data.dynamic_instructions_mode || data.dynamicInstructionsMode || "addon",
            firstMessage: data.first_message || null,
            prepFirstMessage: data.first_message || null,
            isDemoCall: data.is_demo === true,
            transcripts: { user: [], assistant: [] },
            toolCalls: [],
            toolCallLog: [],
            dynamicTools: dynamicTools || null,  // NEW v7
            playbook: playbook || null,           // NEW v7
            sessionCreated: false,
            sessionReady: false,
            greetingMessageSent: false,
            greetingTriggered: false,
            callEnding: false,
            voicemailHandled: false,
            firstAudioSent: false,
            pendingSessionUpdate: false,
            responseLock: { isLocked: false, lockedBy: null, lockedAt: null },
            metrics: { t_session_created: Date.now() },
            createdAt: Date.now()
          };

          if (data.contact_name) {
            session.preloadedContact = {
              name: data.contact_name,
              safeName: BusinessNameDetector.getSafeContactName(data.contact_name),
              email: data.contact_email || null,
              language: data.contact_language || DEFAULT_LANGUAGE
            };
          }

          // Connect to OpenAI for prewarm
          await OpenAIHandler.connect(session);

          let responded = false;

          // Listen for session.updated to confirm prewarm is ready
          session.openaiWs.on("message", (msgData) => {
            const event = Parser.safeJsonParse(msgData.toString(), null);
            if (!event) return;

            if (event.type === "session.created") {
              session.sessionCreated = true;
              OpenAIHandler.sendSessionUpdate(session);
            }

            if (event.type === "session.updated" && !responded) {
              session.sessionReady = true;
              responded = true;
              prewarmSessions.set(prepId, session);
              res.writeHead(200, { "Content-Type": "application/json" });
              res.end(JSON.stringify({
                success: true,
                prep_id: prepId,
                session_ready: true,
                timing_ms: Date.now() - prewarmStart,
                dynamic_tools_loaded: !!dynamicTools,
                playbook_loaded: !!playbook
              }));
            }
          });

          // Timeout fallback
          setTimeout(() => {
            if (!responded) {
              responded = true;
              prewarmSessions.set(prepId, session);
              res.writeHead(200, { "Content-Type": "application/json" });
              res.end(JSON.stringify({
                success: true,
                prep_id: prepId,
                session_ready: false,
                note: "Timeout â€” stored but not fully ready"
              }));
            }
          }, SESSION_UPDATE_TIMEOUT_MS);

        } catch (error) {
          logger.error("Prewarm API error", { error: error.message });
          res.writeHead(500, { "Content-Type": "application/json" });
          res.end(JSON.stringify({ error: error.message }));
        }
      });
      return;
    }

    // 404 Not Found
    res.writeHead(404, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ error: "Not found" }));
  } catch (error) {
    logger.error("HTTP request error", { path, method: req.method, error: error.message });
    res.writeHead(500, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ error: "Internal server error" }));
  }
});

/**
 * WebSocket Server for Twilio Media Streams
 */
const wss = new WebSocketServer({ server, path: "/twilio-stream" });

wss.on("connection", async (ws, request) => {
  try {
    await TwilioHandler.handleConnection(ws, request);
  } catch (error) {
    logger.error("WebSocket connection error", { error: error.message });
    ws.close(1011, "Internal error");
  }
});

wss.on("error", (error) => {
  logger.error("WebSocket server error", { error: error.message });
});

/**
 * Start server
 */
server.listen(PORT, () => {
  logger.info("Voice Gateway started", { version: VERSION, port: PORT, pid: process.pid });

  console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                           â•‘
â•‘  VOICE GATEWAY v${VERSION} â€” ENTERPRISE EDITION            â•‘
â•‘                                                           â•‘
â•‘  ðŸš€ Server running on port ${PORT}                          â•‘
â•‘  ðŸ“Š Metrics: http://localhost:${PORT}/metrics               â•‘
â•‘  â¤ï¸  Health:  http://localhost:${PORT}/health                â•‘
â•‘  ðŸ”Œ WebSocket: ws://localhost:${PORT}/twilio-stream          â•‘
â•‘                                                           â•‘
â•‘  Architecture: 27 OOP Classes (10 sections)               â•‘
â•‘  âœ… Multi-tenant (agents_new + bc_agents)                 â•‘
â•‘  âœ… Circuit breakers & exponential backoff                â•‘
â•‘  âœ… Prewarm with forceNewSession/skipPrewarm              â•‘
â•‘  âœ… Dynamic instructions (full/addon) + Base64            â•‘
â•‘  âœ… Voicemail/IVR detection + auto-hangup                 â•‘
â•‘  âœ… Spam filtering & rate limiting                        â•‘
â•‘  âœ… Tool deduplication & response locking                 â•‘
â•‘  âœ… Business name detection                               â•‘
â•‘  âœ… Webhook support for post-call events                  â•‘
â•‘  âœ… Structured JSON logging + metrics                     â•‘
â•‘  âœ… Graceful shutdown + fatal error handling               â•‘
â•‘  âœ… Full exports for testing                              â•‘
â•‘                                                           â•‘
â•‘  NEW v7.0.0 Features:                                     â•‘
â•‘  âœ… Dynamic Tools from DB (bc_agent_tools)                â•‘
â•‘  âœ… ElevenLabs TTS (stability, style, speed)              â•‘
â•‘  âœ… Playbooks injection (bc_agent_playbooks)              â•‘
â•‘  âœ… Tool call logging (persistent)                        â•‘
â•‘  âœ… Configurable STT (provider, language, model)          â•‘
â•‘  âœ… Configurable AI model (from bc_agents)                â•‘
â•‘  âœ… Dynamic temperature / max_tokens                      â•‘
â•‘  âœ… Cache invalidation endpoint                           â•‘
â•‘                                                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  `);
});

// ============================================================
// GRACEFUL SHUTDOWN & ERROR HANDLING
// ============================================================

process.on("SIGTERM", async () => {
  logger.info("SIGTERM received, shutting down gracefully");
  wss.close(() => { logger.info("WebSocket server closed"); });
  server.close(() => { logger.info("HTTP server closed"); process.exit(0); });
  setTimeout(() => { logger.error("Forced shutdown after timeout"); process.exit(1); }, 10000);
});

process.on("SIGINT", () => { process.emit("SIGTERM"); });

process.on("uncaughtException", (error) => {
  logger.fatal("Uncaught exception", { error: error.message, stack: error.stack });
  process.exit(1);
});

process.on("unhandledRejection", (reason, promise) => {
  logger.fatal("Unhandled rejection", { reason: String(reason) });
  process.exit(1);
});

// ============================================================
// EXPORTS FOR TESTING
// ============================================================

export {
  // Utilities
  Logger,
  Validator,
  Parser,
  // Resilience
  RetryManager,
  CircuitBreaker,
  RateLimiter,
  // State
  SessionManager,
  ResponseLockManager,
  // External Services
  SupabaseClient,
  CRMToolsClient,
  WebhookClient,
  ElevenLabsTTSClient,      // NEW v7
  // Business Logic
  BusinessNameDetector,
  LanguageDetector,
  VoicemailDetector,
  AutoHangupManager,
  SpamFilter,
  ToolDeduplicator,
  PromptBuilder,
  VoiceMapper,
  DynamicToolLoader,         // NEW v7
  PlaybookLoader,            // NEW v7
  ToolCallLogger,            // NEW v7
  // Execution
  ToolExecutor,
  // Handlers
  OpenAIHandler,
  TwilioHandler,
  // Observability
  MetricsCollector,
  HealthCheck
};
